{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/postMessage.png","path":"img/postMessage.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/eren.png","path":"css/images/eren.png","modified":0,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1523153693956},{"_id":"source/_posts/Redux理解和应用.md","hash":"66c806410dccb03956d08e89ab74a37d7b8ba125","modified":1530525807093},{"_id":"source/_posts/function-组件-sdk.md","hash":"c169c547a67ecd81ac06333bcb6cf2bbcd96ce17","modified":1528423632713},{"_id":"source/_posts/前端单页系统的权限控制.md","hash":"5cf63744ef9638ef17a01b3dc3ac5e99a0465655","modified":1543388865468},{"_id":"source/_posts/理解正则表达式.md","hash":"15c185dc2efdf3e616332eaf52dbf539a45bab4f","modified":1528792824821},{"_id":"source/_posts/单例模式理解和应用.md","hash":"fc0ac4cae39af7640cab76dcb358507eb7b10689","modified":1531986747655},{"_id":"source/_posts/postMesage-理解和应用.md","hash":"99deea656a1025d840163ce87135da28816458bc","modified":1523189625006},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1523153693955},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1523153693956},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1523153693957},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1523153693957},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1523153693957},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1523153693958},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1523153693960},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1523153693960},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1523153693960},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1523153693960},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1523153693961},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1523153693966},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1523153693966},{"_id":"themes/beantech/layout/layout.ejs","hash":"545c9544823c4fc6ed797d459e79303d0be95844","modified":1523171824549},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1523153693967},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1523153693968},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1523153693970},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1523153693969},{"_id":"source/img/postMessage.png","hash":"081b5b6977799fc944c2788323ba24a3b2a86e1b","modified":1523153693955},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1523153693969},{"_id":"themes/beantech/layout/post1.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1523171646942},{"_id":"source/_posts/Redux理解和应用/redux.png","hash":"1d3cef1e478bd077d6afc4f3083d4fd3783fc645","modified":1530242341425},{"_id":"source/_posts/function-组件-sdk/component1.png","hash":"21e0407546967bc8164817d0ed1f3e8a5cb5251e","modified":1527658608980},{"_id":"source/_posts/postMesage-理解和应用/postMessage.png","hash":"e5f4ec065644fc70485e6ff6bde133a21d0ab9b8","modified":1523153693932},{"_id":"source/_posts/function-组件-sdk/component2.png","hash":"e6f2bbc1629d7272133a9ba87a12a7011791695a","modified":1527648755646},{"_id":"source/_posts/postMesage-理解和应用/postMessage1.png","hash":"1edd42f320246c675e0316196feb1297ee8b72fb","modified":1523153693934},{"_id":"source/_posts/理解正则表达式/reg.png","hash":"9ba166b8a490a765912c3b220bfe3b1e2510be58","modified":1527845183285},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1523153693962},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1523153693962},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1523153693963},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1523153693961},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1523153693963},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1523153693964},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1523153693964},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1523153693964},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1523153693965},{"_id":"source/_posts/function-组件-sdk/postMessage.png","hash":"e5f4ec065644fc70485e6ff6bde133a21d0ab9b8","modified":1523153693932},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1523153693965},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1523153693965},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1523153693970},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1523153693966},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1523153693962},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1523153693971},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1523153693971},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1523153693974},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1523153693976},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1523153693974},{"_id":"themes/beantech/source/css/rocket.styl","hash":"869b35aebb722c060970ea65284f32e3a28bf7e6","modified":1530170969521},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1523153693976},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1523153693976},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1523153693978},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1523153693977},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1523153693979},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1523153693979},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1523153693980},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1523153693980},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1523153693981},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1523153693985},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1523153693984},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1523153693985},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1523153693973},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1523153693977},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1523153693980},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523153693984},{"_id":"source/img/avatar.png","hash":"851a8c8a981a24673cf3debe22603039995a581d","modified":1523153693935},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1523153693972},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1523153693984},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1523153693975},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1523153693975},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1523153693983},{"_id":"themes/beantech/source/css/images/eren.png","hash":"62d5e24849cf0f9dce7ded39356d5d5dff4d9a30","modified":1530170866122},{"_id":"source/img/home-bg.jpg","hash":"2b2b23f60a13f73892ed93b09418cb418139ca6c","modified":1523153693953},{"_id":"public/2018/07/19/单例模式理解和应用/index.html","hash":"6d101087d884a1be0411e2bfa2745fc19ed6cd08","modified":1543389035675},{"_id":"public/2018/06/12/理解正则表达式/index.html","hash":"3df358bb893f5dc085279b0bd417e3807cd30fcc","modified":1543389035699},{"_id":"public/2018/06/08/function-组件-sdk/index.html","hash":"dbc6b073012f4bf323bb95dd9d2ada54187727da","modified":1543389035706},{"_id":"public/2018/04/09/Redux理解和应用/index.html","hash":"2a1f7ea9a655d306807e0c13d50fc51b7af119f0","modified":1543389035706},{"_id":"public/2018/02/27/postMesage-理解和应用/index.html","hash":"2e5f5481c95cb50b9b9f7e1684a33d99bef25012","modified":1543389035706},{"_id":"public/archives/index.html","hash":"662b893e4704976747cfb76e96224d29045e8f69","modified":1543389035706},{"_id":"public/archives/2018/index.html","hash":"1c7d21e6b403f3d3dafa201c07a50a9aa47c48c1","modified":1543389035706},{"_id":"public/archives/2018/02/index.html","hash":"4d65faea2a90ffd441fa8f35e9e9f2d0f923f1b8","modified":1543389035706},{"_id":"public/archives/2018/04/index.html","hash":"565a6452eaa3a08b09bfce3c2f7b324c2c2fdf3e","modified":1543389035707},{"_id":"public/archives/2018/06/index.html","hash":"82f6a3b260e9a3b38114793acbb335466135ffe3","modified":1543389035707},{"_id":"public/archives/2018/07/index.html","hash":"493b112e410555427e5127916256af7ae1bec764","modified":1543389035707},{"_id":"public/tags/前端/index.html","hash":"11a87a125b510380c89a259dcd35d585a41a1e7d","modified":1543389035707},{"_id":"public/tags/js/index.html","hash":"1c1ce0387fd41c38799e23ec2eadf3e533e1e602","modified":1543389035707},{"_id":"public/tags/redux/index.html","hash":"d8636a11b2b35de7aea745f01611188e7765b445","modified":1543389035707},{"_id":"public/tags/react/index.html","hash":"2fe3e34d08b3df5193171ef5d44636b099c332b9","modified":1543389035707},{"_id":"public/tags/组件/index.html","hash":"88eb6445eb1a786588cbac0fffdaf3c8a2dd3f9d","modified":1543389035707},{"_id":"public/tags/正则表达式/index.html","hash":"1b77f5da497ebcd7bdcd9933cfd9889355d52ff0","modified":1543389035707},{"_id":"public/tags/模式/index.html","hash":"592c519d781535bf3524607453e6ec0ea180f91d","modified":1543389035707},{"_id":"public/tags/跨域/index.html","hash":"80725931812428bda2e332a907d423dfae8a5141","modified":1543389035707},{"_id":"public/index.html","hash":"ed21127253d575037057b08ee37f5711a0a0af04","modified":1543389035707},{"_id":"public/2018/11/28/前端单页系统的权限控制/index.html","hash":"0dffdbd4ee701d9129690c2e2f06c05e0feb1bd3","modified":1543389035731},{"_id":"public/archives/2018/11/index.html","hash":"66ece7688a141631c8f43a27a14547611f288a81","modified":1543389035731},{"_id":"public/tags/单页/index.html","hash":"a5449f794da5a3e25bfa8186edaeabe3591e54be","modified":1543389035731},{"_id":"public/tags/路由/index.html","hash":"ee97faa26ba5ec2d32549ce977a970eb706a5c86","modified":1543389035731},{"_id":"public/tags/权限/index.html","hash":"d5979a429c02a4781c69bcef8b80d4f875b87299","modified":1543389035731},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1543389035733},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1543389035734},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1543389035734},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1543389035734},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1543389035734},{"_id":"public/css/images/eren.png","hash":"62d5e24849cf0f9dce7ded39356d5d5dff4d9a30","modified":1543389035734},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1543389035734},{"_id":"public/2018/04/09/Redux理解和应用/redux.png","hash":"1d3cef1e478bd077d6afc4f3083d4fd3783fc645","modified":1543389035734},{"_id":"public/2018/06/08/function-组件-sdk/component2.png","hash":"e6f2bbc1629d7272133a9ba87a12a7011791695a","modified":1543389035734},{"_id":"public/2018/06/08/function-组件-sdk/component1.png","hash":"21e0407546967bc8164817d0ed1f3e8a5cb5251e","modified":1543389035735},{"_id":"public/2018/06/08/function-组件-sdk/postMessage.png","hash":"e5f4ec065644fc70485e6ff6bde133a21d0ab9b8","modified":1543389035735},{"_id":"public/2018/06/12/理解正则表达式/reg.png","hash":"9ba166b8a490a765912c3b220bfe3b1e2510be58","modified":1543389035735},{"_id":"public/2018/02/27/postMesage-理解和应用/postMessage1.png","hash":"1edd42f320246c675e0316196feb1297ee8b72fb","modified":1543389035735},{"_id":"public/2018/02/27/postMesage-理解和应用/postMessage.png","hash":"e5f4ec065644fc70485e6ff6bde133a21d0ab9b8","modified":1543389037291},{"_id":"public/img/postMessage.png","hash":"081b5b6977799fc944c2788323ba24a3b2a86e1b","modified":1543389037291},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1543389037295},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1543389037317},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1543389037317},{"_id":"public/css/rocket.css","hash":"30e66dd8d1f3895f6eaa5638203e170c344aebee","modified":1543389037317},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1543389037317},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1543389037317},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1543389037317},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1543389037317},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1543389037317},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1543389037317},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1543389037317},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1543389037317},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1543389037317},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1543389037317},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1543389037317},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1543389037317},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1543389037317},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543389037317},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1543389037317},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1543389037318},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1543389037318},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1543389037318},{"_id":"public/img/avatar.png","hash":"851a8c8a981a24673cf3debe22603039995a581d","modified":1543389037431},{"_id":"public/img/home-bg.jpg","hash":"2b2b23f60a13f73892ed93b09418cb418139ca6c","modified":1543389037457}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"'Redux理解和应用'","date":"2018-04-09T12:09:41.000Z","_content":"\n# Redux理解和应用\n\n> 写在前面：说到redux就不得不说react，之前做过一个项目是纯用react的，所有的数据都使用props和state来管理。无赖后来没有等到项目引进redux就终止了。那时候觉得没有使用redux，react也能自己很好的管理自己的数据，组件之间的通信仅仅是通过props或者回调函数来完成（组件之间的通信参看https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。\n\n\n\n## Redux解决了什么问题\n\nredux是一种解决方案。react只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。redux并不是必须要用的。但是当组件之间涉及到下面的场景，就需要引入redux。\n\n- 某个组件的状态，需要共享\n- 某个状态需要在任何地方都可以拿到\n- 一个组件需要改变全局状态\n- 一个组件需要改变另一个组件的状态\n\n发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。\n\n\n\n## 设计理念\n\n在接触mvvm的框架的时候会有一些感觉，我们是通过改变数据来改变视图的，因为mvvm框架通常是双向绑定的。react是单向数据流，我们也可以通过某种手段使得同样的数据对应同样的视图。redux的设计理念就是，所有的数据都由store来管理。所有的变动都由action来发起。当view层发起一个action以后，最后由reducers来执行，reducers是一个纯函数，也就是说，只要是同样的输入，必定得到同样的输出。经过reducer处理返回新的state更新到store中。这样的流程使得所有的数据更新都要通过这个流程。\n\n可以理解为一个所有的组件都共用一个store，这样，第一小节中提到的：组件的状态，需要共享；某个状态需要在任何地方都可以拿到；一个组件需要改变全局状态；一个组件需要改变另一个组件的状态等组件之间的通行或者跨页面之间的共享问题就得到解决。\n\n有了redux的规范，项目的文件也会更加清晰，同时也提升了开发体验\n\n\n\n## Redux工作流程\n\n![Redux工作流程](Redux理解和应用/redux.png)\n\n整个工作流程是，view层触发action，store更具action找到对应的reducer，并将当前state和action传给reducer，reducer处理完数据以后返回新的state，view层根据新的state更新视图。\n\n## 基本概念\n\n### Store\n\nStore 就是保存数据的一个对象，一个容器。整个应用有一个 Store。\n\nRedux 提供`createStore`这个函数，用来生成 Store。\n\n```js\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\n```\n\n参数reducer是个function如下，传入两个参数，一个是初始State，一个是action\n\n```js\nconst reducer= (state = initialState, action) => state;\n```\n\n最终，store是一个类似这样的对象：\n\n```js\nconst store = {\n  currentState: initialState,\n  dispatch: (action) => { currentState = reducer(currentState, action)},\n  getState: () => currentState,\n  subscribe: () = (listener) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    }\n  };\n}\n```\n\n这个对象返回三个方法，dispatch，subscribe和getState，dispatch触发以后会修改state，getState会返回当前的state。\n\n#### store.dispatch()\n\nview想要更新数据state的唯一方法。\n\n```js\nstore.dispatch({\n  type: types.LIST,\n  data: res\n})\n```\n\ndispatch接受的参数是action。当view层调用dispatch以后，store会根据type: types.LIST的值来判断调用那个一个具体的Reducer。这一步store怎么知道有哪些Reducers是可以搜索的呢，其实是因为，所有的Reducers都经过createStore()处理。具体的细节我还会再写一篇关于原理的笔记。\n\n```\n var store = createStore(Reducers);\n```\n\n#### store.subscribe()\n\n添加监听函数,这些函数会在每次dispatch action的时候调用，比如react就是把render()加入监听函数列表,这样每次dispatch action都会触发render()，重新渲染页面。\n\n#### store.getState()\n\n返回当前的state\n\n\n\n### state\n\n`Store`对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照。这种快照，就叫做 State。\n\n当前时刻的 State，可以通过`store.getState()`拿到。State也是一个对象。一个State对应一个view，所以相同的State就会有相同的view。有一种说法，可以理解为state是数据流，随着时间移动，某部分state的数据会改变，而view就是state改变的体现。就像是ps中，你的每个操作都会生成一个历史记录，操作前是上一个state的快照，操作后是当前state快照，你的操作就是action。\n\n\n\n### action\n\naction是唯一可以改变state的方法。state的改变会导致view层的改变。redux的设计就是希望所有对state的修改都只能通过action来触发。所以action是view层想要改变的唯一方法。action是一个对象，其中type是必须的，表示触发哪个action。\n\n```\n{\n  type: types.LIST,\n  data: res\n}\n```\n\n### \n\n## Reducer\n\n首先，reducer是一个方法，这个方法可以接受两个参数，一个是当前的state，一个是触发的action。\n\nreducer就是最后定义新state返回的函数，这个函数会根据不同的action，返回新的state。随着state的更新，view就也发生了更新。\n\n```js\nconst reducerA =  function (state, action) {\n    state = state || initState;\n    switch (action.type) {\n      case LIST:\n        return Object.assign(state, {\n          tableData: action.data\n        });\n      case DETAIL:\n        return Object.assign(state, {\n          detailData: action.data\n        });\n      default:\n        return state;\n    }\n  }\n```\n\nreducer有个非常重要的属性，就是它是一个**纯函数**。纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出，并且不修改原来的state，只是反回新的state。redux会根据新旧state的引用地址否相同来判断是否更新state。\n\n\n\n## 进阶\n\n看了上面的基本概念，在看工作流程的那张图，感觉好像明白了一些，接下来，看看实际中，怎么运用。\n\n看看图中大致的流程，view层可以触发很多action，这些action可以按照时间顺序修改store中的state，state改变就可以触发view改变。\n\n#### 第一步 生成reducers \n\n最直观的想，第一步是view层触发action，而文档中说明只有store.dispatch()触发action，所以，store是所有的根本。怎么生成store？\n\n前面说过，只需要引入redux，调用 createStore方法，传入reducers。\n\nreducer是一个方法，如reducer一节例子那样。但是如何项目有无数action，那么就会有无数的case来处理，这样的话，reducer可能有上千行，导致代码很难维护。所有我们需要将reducer按照功能模块进行拆分。\n\n假如把reducer一节例子分成两个功能模块：A 和B。\n\n那么reducerA是这样：\n\n```js\nreturn function (state, action) {\n  state = state || initState;\n  switch (action.type) {\n    case LIST:\n      return Object.assign(state, {\n        tableData: action.data\n      });\n    default:\n      return state;\n  }\n}\n```\n\nreducerB是这样:\n\n```js\nreturn function (state, action) {\n  state = state || initState;\n  switch (action.type) {\n    case DETAIL:\n      return Object.assign(state, {\n        tableData: action.data\n      });\n    default:\n      return state;\n  }\n}\n```\n\n然后把两个reducer用**combineReducers** 组合起来。\n\n`combineReducers` 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducers 函数，然后就可以对这个 reducers调用 [`createStore`](http://cn.redux.js.org/docs/api/createStore.html) 方法。\n\n```js\nimport { combineReducers } from 'redux';\nimport * as reducerA from './reducerA';\nimport * as reducerB from './reducerB';\n\nreturn combineReducers({\n  A: reducerA,\n  B: reducerB\n})\n```\n\n也可以直接这样：\n\n```js\nimport { combineReducers } from 'redux';\nimport * as reducerA from './reducerA';\nimport * as reducerB from './reducerB';\n\nreturn combineReducers({\n  reducerA,\n  reducerB\n})\n```\n\n两种区别是上面一种可以重新命名state的变量名，下面这种默认state中变量名和reducer同名。\n\n合并后的 reducers 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 **由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名**。\n\n所以上面的例子对应的state就是下面这样：\n\n```\n{ reducerA, reducerB }\n```\n\n这样，我们就把一个大的reducer拆分成两个模块，并且在state中分别对应不同的变量。实际的项目中可能拆成很多模块，每个模块自己维护自己在state中的变量。\n\n#### 第二步 生成store\n\n上面说了这么多就是为了能给**createStore** 方法造一个参数，reducers终于参数造好了。\n\n```js\nimport { createStore } from 'redux';\nimport * as reducers from './reducer';\n\nconst store = createStore(reducers);\n```\n\n有了store，就可以使用store的三个方法，dispatch，subscribe和getState。\n\n#### 第三步 dispatch action\n\n看起来好像是这样的\n\n```\nstore.dispatch({\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n});\n```\n\n然鹅，实际的运用中，根本不是这样。\n\n实际的action并不是写成{ type: 'ADD_TODO', payload: 'Learn Redux'}这样，而是\n\n```js\nexport const getList = (data, params) => {\n  return {\n    type: types.GET_LIST_COMPLETE,\n    params: params\n  }\n}\n\nexport const createAccount = (data, params) => {\n  return {\n    type: types.TEST_CREATE_ACCOUNT,\n    params: params\n  }\n}\n```\n\n通过一个方法来返回这个action。\n\n这样做的目的是，可以调用**bindActionCreators** 方法，该方法的返回值是一个对象，可以通过对象的值直接调用dispatch(action)(隐式调用）。所以在实际的运用中并没有到处都是store.dispatch()。\n\n```js\nimport * as actions from '../actions';\n\nconst action = bindActionCreators(actions, dispatch); \n\n//返回值action\n{\n  getList:  function(){\n    return dispatch({ type: types.GET_LIST_COMPLETE, params: params })\n  }，\n  createAccount:  function(){\n    return dispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n  }\n}\n```\n\n这时候只要使用action.getList()就可以触发action。\n\n````js\naction.getList()\n//等价于\n(funciton(){\n\tdispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n})()\n//等价于\nfuncion getList (){\n  dispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n}\ngetList();\n````\n\n\n\n## 补充\n\n### reducer为什么必须是**纯函数**?\n\n* 首先纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出。\n\n  redux的store中数据是随着时间不断变化的，如果所有的reducer都是纯函数，那么state的每一步变化都，可以用前一个state和后一个state进行还原，有利于测试。\n\n* 再次，纯函数不修改外部变量，只依赖入参，每次执行action以后，不修改原来的state，只是反回新的state。\n\n  为什么这么做？来看看combineReducers方法中的源码\n\n  ```js\n   var hasChanged = false\n      var nextState = {}\n      // 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用\n      for (var i = 0; i < finalReducerKeys.length; i++) {\n        var key = finalReducerKeys[i]\n        var reducer = finalReducers[key]\n        // 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因\n        var previousStateForKey = state[key]\n        var nextStateForKey = reducer(previousStateForKey, action)\n        // 如果reducer返回undefined则抛出错误\n        if (typeof nextStateForKey === 'undefined') {\n          var errorMessage = getUndefinedStateErrorMessage(key, action)\n          throw new Error(errorMessage)\n        }\n        // 将reducer返回的值填入nextState\n        nextState[key] = nextStateForKey\n        // 如果任一state有更新则hasChanged为true\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n      }\n      return hasChanged ? nextState : state\n  ```\n\n  看倒数第二行` hasChanged = hasChanged || nextStateForKey !== previousStateForKey` 最终判断是不是发生变化返回的是`nextStateForKey !== previousStateForKey` ，也就是说比较的是两个state的引用是不是同一个。如果reducer返回不是一个新的state，那么这里的引用是同一个，就不会更新store。\n\n  在js中的对象有两种比较，一种是简单的引用比较，就是比较两个值的的引用地址是不是同一个，浅比较；还有一种比较两个js对象所有的属性是否相同也叫深比较。深比较由于需要层层循环对象来比较，对比的次数很多，开销非常大。\n\n  reducer这里正好利用了纯函数的优点，每个reducer最后都返回一个新对象，这样可以用过简单的引用比较（!==）判断是否更新，节约了代码运行成本。可以说是设计的精髓所在。\n\n\n\n### 纯函数式编程优缺点\n\n上面说到了纯函数，不由得让人想起纯函数编程。\n\n#### 什么是纯函数编程\n\n我的理解，`纯函数编程` 是一种编程规范，就像`面向对象编程` 一样。主要思路是把运算过程尽量写成一系列嵌套的函数调用。\n\n#### 有什么特点\n\n* **函数只是普通对象**  函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n* **只用\"表达式\"，不用\"语句\"** 不做赋值的操作\n* **没有\"副作用\"** 由于纯函数只依赖输入的参数，所以只要相同的输入一定能得到相同的结果\n* **不修改状态** 函数式编程只是返回新的值，不修改系统变量。\n\n这样就可以得出纯函数基本的原则：\n\n- 不得改写参数\n- 不能调用系统 I/O 的API\n- 不能调用`Date.now()`或者`Math.random()`等不纯的方法，因为每次会得到不一样的结果\n\n#### 有什么优点\n\n* **代码简洁，开发快速**  函数式编程进而可以写成链式，代码简介\n* **易于\"并发编程\"**  由于代码的执行只和输入的参数有关，和先后顺序无关，所以没有锁等问题\n* **代码的热升级** \n* **易于测试**  只要给出同样的输入，就一定会得到相同结果，易于功能测试\n\n具体还可以参看这篇文章：http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\n\n#### 有什么缺点\n\n* **代码很难读懂，入门困难** \n\n* **很多地方使用了递归，导致函数式语言的运行速度比较慢** \n\n* **方法不能继承，即使很相似的方法也得重新编写。** \n\n* **面向对象编程的优点“封装”“继承”“多态”就是纯函数编程的缺点。**\n\n  ​","source":"_posts/Redux理解和应用.md","raw":"---\ntitle: '''Redux理解和应用'''\ndate: 2018-04-09 20:09:41\ntags:\n- 前端\n- js\n- redux\n- react\n---\n\n# Redux理解和应用\n\n> 写在前面：说到redux就不得不说react，之前做过一个项目是纯用react的，所有的数据都使用props和state来管理。无赖后来没有等到项目引进redux就终止了。那时候觉得没有使用redux，react也能自己很好的管理自己的数据，组件之间的通信仅仅是通过props或者回调函数来完成（组件之间的通信参看https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。\n\n\n\n## Redux解决了什么问题\n\nredux是一种解决方案。react只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。redux并不是必须要用的。但是当组件之间涉及到下面的场景，就需要引入redux。\n\n- 某个组件的状态，需要共享\n- 某个状态需要在任何地方都可以拿到\n- 一个组件需要改变全局状态\n- 一个组件需要改变另一个组件的状态\n\n发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。\n\n\n\n## 设计理念\n\n在接触mvvm的框架的时候会有一些感觉，我们是通过改变数据来改变视图的，因为mvvm框架通常是双向绑定的。react是单向数据流，我们也可以通过某种手段使得同样的数据对应同样的视图。redux的设计理念就是，所有的数据都由store来管理。所有的变动都由action来发起。当view层发起一个action以后，最后由reducers来执行，reducers是一个纯函数，也就是说，只要是同样的输入，必定得到同样的输出。经过reducer处理返回新的state更新到store中。这样的流程使得所有的数据更新都要通过这个流程。\n\n可以理解为一个所有的组件都共用一个store，这样，第一小节中提到的：组件的状态，需要共享；某个状态需要在任何地方都可以拿到；一个组件需要改变全局状态；一个组件需要改变另一个组件的状态等组件之间的通行或者跨页面之间的共享问题就得到解决。\n\n有了redux的规范，项目的文件也会更加清晰，同时也提升了开发体验\n\n\n\n## Redux工作流程\n\n![Redux工作流程](Redux理解和应用/redux.png)\n\n整个工作流程是，view层触发action，store更具action找到对应的reducer，并将当前state和action传给reducer，reducer处理完数据以后返回新的state，view层根据新的state更新视图。\n\n## 基本概念\n\n### Store\n\nStore 就是保存数据的一个对象，一个容器。整个应用有一个 Store。\n\nRedux 提供`createStore`这个函数，用来生成 Store。\n\n```js\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\n```\n\n参数reducer是个function如下，传入两个参数，一个是初始State，一个是action\n\n```js\nconst reducer= (state = initialState, action) => state;\n```\n\n最终，store是一个类似这样的对象：\n\n```js\nconst store = {\n  currentState: initialState,\n  dispatch: (action) => { currentState = reducer(currentState, action)},\n  getState: () => currentState,\n  subscribe: () = (listener) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    }\n  };\n}\n```\n\n这个对象返回三个方法，dispatch，subscribe和getState，dispatch触发以后会修改state，getState会返回当前的state。\n\n#### store.dispatch()\n\nview想要更新数据state的唯一方法。\n\n```js\nstore.dispatch({\n  type: types.LIST,\n  data: res\n})\n```\n\ndispatch接受的参数是action。当view层调用dispatch以后，store会根据type: types.LIST的值来判断调用那个一个具体的Reducer。这一步store怎么知道有哪些Reducers是可以搜索的呢，其实是因为，所有的Reducers都经过createStore()处理。具体的细节我还会再写一篇关于原理的笔记。\n\n```\n var store = createStore(Reducers);\n```\n\n#### store.subscribe()\n\n添加监听函数,这些函数会在每次dispatch action的时候调用，比如react就是把render()加入监听函数列表,这样每次dispatch action都会触发render()，重新渲染页面。\n\n#### store.getState()\n\n返回当前的state\n\n\n\n### state\n\n`Store`对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照。这种快照，就叫做 State。\n\n当前时刻的 State，可以通过`store.getState()`拿到。State也是一个对象。一个State对应一个view，所以相同的State就会有相同的view。有一种说法，可以理解为state是数据流，随着时间移动，某部分state的数据会改变，而view就是state改变的体现。就像是ps中，你的每个操作都会生成一个历史记录，操作前是上一个state的快照，操作后是当前state快照，你的操作就是action。\n\n\n\n### action\n\naction是唯一可以改变state的方法。state的改变会导致view层的改变。redux的设计就是希望所有对state的修改都只能通过action来触发。所以action是view层想要改变的唯一方法。action是一个对象，其中type是必须的，表示触发哪个action。\n\n```\n{\n  type: types.LIST,\n  data: res\n}\n```\n\n### \n\n## Reducer\n\n首先，reducer是一个方法，这个方法可以接受两个参数，一个是当前的state，一个是触发的action。\n\nreducer就是最后定义新state返回的函数，这个函数会根据不同的action，返回新的state。随着state的更新，view就也发生了更新。\n\n```js\nconst reducerA =  function (state, action) {\n    state = state || initState;\n    switch (action.type) {\n      case LIST:\n        return Object.assign(state, {\n          tableData: action.data\n        });\n      case DETAIL:\n        return Object.assign(state, {\n          detailData: action.data\n        });\n      default:\n        return state;\n    }\n  }\n```\n\nreducer有个非常重要的属性，就是它是一个**纯函数**。纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出，并且不修改原来的state，只是反回新的state。redux会根据新旧state的引用地址否相同来判断是否更新state。\n\n\n\n## 进阶\n\n看了上面的基本概念，在看工作流程的那张图，感觉好像明白了一些，接下来，看看实际中，怎么运用。\n\n看看图中大致的流程，view层可以触发很多action，这些action可以按照时间顺序修改store中的state，state改变就可以触发view改变。\n\n#### 第一步 生成reducers \n\n最直观的想，第一步是view层触发action，而文档中说明只有store.dispatch()触发action，所以，store是所有的根本。怎么生成store？\n\n前面说过，只需要引入redux，调用 createStore方法，传入reducers。\n\nreducer是一个方法，如reducer一节例子那样。但是如何项目有无数action，那么就会有无数的case来处理，这样的话，reducer可能有上千行，导致代码很难维护。所有我们需要将reducer按照功能模块进行拆分。\n\n假如把reducer一节例子分成两个功能模块：A 和B。\n\n那么reducerA是这样：\n\n```js\nreturn function (state, action) {\n  state = state || initState;\n  switch (action.type) {\n    case LIST:\n      return Object.assign(state, {\n        tableData: action.data\n      });\n    default:\n      return state;\n  }\n}\n```\n\nreducerB是这样:\n\n```js\nreturn function (state, action) {\n  state = state || initState;\n  switch (action.type) {\n    case DETAIL:\n      return Object.assign(state, {\n        tableData: action.data\n      });\n    default:\n      return state;\n  }\n}\n```\n\n然后把两个reducer用**combineReducers** 组合起来。\n\n`combineReducers` 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducers 函数，然后就可以对这个 reducers调用 [`createStore`](http://cn.redux.js.org/docs/api/createStore.html) 方法。\n\n```js\nimport { combineReducers } from 'redux';\nimport * as reducerA from './reducerA';\nimport * as reducerB from './reducerB';\n\nreturn combineReducers({\n  A: reducerA,\n  B: reducerB\n})\n```\n\n也可以直接这样：\n\n```js\nimport { combineReducers } from 'redux';\nimport * as reducerA from './reducerA';\nimport * as reducerB from './reducerB';\n\nreturn combineReducers({\n  reducerA,\n  reducerB\n})\n```\n\n两种区别是上面一种可以重新命名state的变量名，下面这种默认state中变量名和reducer同名。\n\n合并后的 reducers 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 **由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名**。\n\n所以上面的例子对应的state就是下面这样：\n\n```\n{ reducerA, reducerB }\n```\n\n这样，我们就把一个大的reducer拆分成两个模块，并且在state中分别对应不同的变量。实际的项目中可能拆成很多模块，每个模块自己维护自己在state中的变量。\n\n#### 第二步 生成store\n\n上面说了这么多就是为了能给**createStore** 方法造一个参数，reducers终于参数造好了。\n\n```js\nimport { createStore } from 'redux';\nimport * as reducers from './reducer';\n\nconst store = createStore(reducers);\n```\n\n有了store，就可以使用store的三个方法，dispatch，subscribe和getState。\n\n#### 第三步 dispatch action\n\n看起来好像是这样的\n\n```\nstore.dispatch({\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n});\n```\n\n然鹅，实际的运用中，根本不是这样。\n\n实际的action并不是写成{ type: 'ADD_TODO', payload: 'Learn Redux'}这样，而是\n\n```js\nexport const getList = (data, params) => {\n  return {\n    type: types.GET_LIST_COMPLETE,\n    params: params\n  }\n}\n\nexport const createAccount = (data, params) => {\n  return {\n    type: types.TEST_CREATE_ACCOUNT,\n    params: params\n  }\n}\n```\n\n通过一个方法来返回这个action。\n\n这样做的目的是，可以调用**bindActionCreators** 方法，该方法的返回值是一个对象，可以通过对象的值直接调用dispatch(action)(隐式调用）。所以在实际的运用中并没有到处都是store.dispatch()。\n\n```js\nimport * as actions from '../actions';\n\nconst action = bindActionCreators(actions, dispatch); \n\n//返回值action\n{\n  getList:  function(){\n    return dispatch({ type: types.GET_LIST_COMPLETE, params: params })\n  }，\n  createAccount:  function(){\n    return dispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n  }\n}\n```\n\n这时候只要使用action.getList()就可以触发action。\n\n````js\naction.getList()\n//等价于\n(funciton(){\n\tdispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n})()\n//等价于\nfuncion getList (){\n  dispatch({ type: types.TEST_CREATE_ACCOUNT, params: params })\n}\ngetList();\n````\n\n\n\n## 补充\n\n### reducer为什么必须是**纯函数**?\n\n* 首先纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出。\n\n  redux的store中数据是随着时间不断变化的，如果所有的reducer都是纯函数，那么state的每一步变化都，可以用前一个state和后一个state进行还原，有利于测试。\n\n* 再次，纯函数不修改外部变量，只依赖入参，每次执行action以后，不修改原来的state，只是反回新的state。\n\n  为什么这么做？来看看combineReducers方法中的源码\n\n  ```js\n   var hasChanged = false\n      var nextState = {}\n      // 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用\n      for (var i = 0; i < finalReducerKeys.length; i++) {\n        var key = finalReducerKeys[i]\n        var reducer = finalReducers[key]\n        // 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因\n        var previousStateForKey = state[key]\n        var nextStateForKey = reducer(previousStateForKey, action)\n        // 如果reducer返回undefined则抛出错误\n        if (typeof nextStateForKey === 'undefined') {\n          var errorMessage = getUndefinedStateErrorMessage(key, action)\n          throw new Error(errorMessage)\n        }\n        // 将reducer返回的值填入nextState\n        nextState[key] = nextStateForKey\n        // 如果任一state有更新则hasChanged为true\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n      }\n      return hasChanged ? nextState : state\n  ```\n\n  看倒数第二行` hasChanged = hasChanged || nextStateForKey !== previousStateForKey` 最终判断是不是发生变化返回的是`nextStateForKey !== previousStateForKey` ，也就是说比较的是两个state的引用是不是同一个。如果reducer返回不是一个新的state，那么这里的引用是同一个，就不会更新store。\n\n  在js中的对象有两种比较，一种是简单的引用比较，就是比较两个值的的引用地址是不是同一个，浅比较；还有一种比较两个js对象所有的属性是否相同也叫深比较。深比较由于需要层层循环对象来比较，对比的次数很多，开销非常大。\n\n  reducer这里正好利用了纯函数的优点，每个reducer最后都返回一个新对象，这样可以用过简单的引用比较（!==）判断是否更新，节约了代码运行成本。可以说是设计的精髓所在。\n\n\n\n### 纯函数式编程优缺点\n\n上面说到了纯函数，不由得让人想起纯函数编程。\n\n#### 什么是纯函数编程\n\n我的理解，`纯函数编程` 是一种编程规范，就像`面向对象编程` 一样。主要思路是把运算过程尽量写成一系列嵌套的函数调用。\n\n#### 有什么特点\n\n* **函数只是普通对象**  函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n* **只用\"表达式\"，不用\"语句\"** 不做赋值的操作\n* **没有\"副作用\"** 由于纯函数只依赖输入的参数，所以只要相同的输入一定能得到相同的结果\n* **不修改状态** 函数式编程只是返回新的值，不修改系统变量。\n\n这样就可以得出纯函数基本的原则：\n\n- 不得改写参数\n- 不能调用系统 I/O 的API\n- 不能调用`Date.now()`或者`Math.random()`等不纯的方法，因为每次会得到不一样的结果\n\n#### 有什么优点\n\n* **代码简洁，开发快速**  函数式编程进而可以写成链式，代码简介\n* **易于\"并发编程\"**  由于代码的执行只和输入的参数有关，和先后顺序无关，所以没有锁等问题\n* **代码的热升级** \n* **易于测试**  只要给出同样的输入，就一定会得到相同结果，易于功能测试\n\n具体还可以参看这篇文章：http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\n\n#### 有什么缺点\n\n* **代码很难读懂，入门困难** \n\n* **很多地方使用了递归，导致函数式语言的运行速度比较慢** \n\n* **方法不能继承，即使很相似的方法也得重新编写。** \n\n* **面向对象编程的优点“封装”“继承”“多态”就是纯函数编程的缺点。**\n\n  ​","slug":"Redux理解和应用","published":1,"updated":"2018-07-02T10:03:27.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzci800005ois5viwdfcx","content":"<h1 id=\"Redux理解和应用\"><a href=\"#Redux理解和应用\" class=\"headerlink\" title=\"Redux理解和应用\"></a>Redux理解和应用</h1><blockquote>\n<p>写在前面：说到redux就不得不说react，之前做过一个项目是纯用react的，所有的数据都使用props和state来管理。无赖后来没有等到项目引进redux就终止了。那时候觉得没有使用redux，react也能自己很好的管理自己的数据，组件之间的通信仅仅是通过props或者回调函数来完成（组件之间的通信参看<a href=\"https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。\" target=\"_blank\" rel=\"noopener\">https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。</a></p>\n</blockquote>\n<h2 id=\"Redux解决了什么问题\"><a href=\"#Redux解决了什么问题\" class=\"headerlink\" title=\"Redux解决了什么问题\"></a>Redux解决了什么问题</h2><p>redux是一种解决方案。react只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。redux并不是必须要用的。但是当组件之间涉及到下面的场景，就需要引入redux。</p>\n<ul>\n<li>某个组件的状态，需要共享</li>\n<li>某个状态需要在任何地方都可以拿到</li>\n<li>一个组件需要改变全局状态</li>\n<li>一个组件需要改变另一个组件的状态</li>\n</ul>\n<p>发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。</p>\n<h2 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h2><p>在接触mvvm的框架的时候会有一些感觉，我们是通过改变数据来改变视图的，因为mvvm框架通常是双向绑定的。react是单向数据流，我们也可以通过某种手段使得同样的数据对应同样的视图。redux的设计理念就是，所有的数据都由store来管理。所有的变动都由action来发起。当view层发起一个action以后，最后由reducers来执行，reducers是一个纯函数，也就是说，只要是同样的输入，必定得到同样的输出。经过reducer处理返回新的state更新到store中。这样的流程使得所有的数据更新都要通过这个流程。</p>\n<p>可以理解为一个所有的组件都共用一个store，这样，第一小节中提到的：组件的状态，需要共享；某个状态需要在任何地方都可以拿到；一个组件需要改变全局状态；一个组件需要改变另一个组件的状态等组件之间的通行或者跨页面之间的共享问题就得到解决。</p>\n<p>有了redux的规范，项目的文件也会更加清晰，同时也提升了开发体验</p>\n<h2 id=\"Redux工作流程\"><a href=\"#Redux工作流程\" class=\"headerlink\" title=\"Redux工作流程\"></a>Redux工作流程</h2><p><img src=\"/2018/04/09/Redux理解和应用/redux.png\" alt=\"Redux工作流程\"></p>\n<p>整个工作流程是，view层触发action，store更具action找到对应的reducer，并将当前state和action传给reducer，reducer处理完数据以后返回新的state，view层根据新的state更新视图。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store 就是保存数据的一个对象，一个容器。整个应用有一个 Store。</p>\n<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>\n<p>参数reducer是个function如下，传入两个参数，一个是初始State，一个是action</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reducer= <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> state;</span><br></pre></td></tr></table></figure>\n<p>最终，store是一个类似这样的对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = &#123;</span><br><span class=\"line\">  currentState: initialState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123; currentState = reducer(currentState, action)&#125;,</span><br><span class=\"line\">  getState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> currentState,</span><br><span class=\"line\">  subscribe: <span class=\"function\"><span class=\"params\">()</span> = (<span class=\"params\">listener</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    listeners.push(listener);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      listeners = listeners.filter(<span class=\"function\"><span class=\"params\">l</span> =&gt;</span> l !== listener);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个对象返回三个方法，dispatch，subscribe和getState，dispatch触发以后会修改state，getState会返回当前的state。</p>\n<h4 id=\"store-dispatch\"><a href=\"#store-dispatch\" class=\"headerlink\" title=\"store.dispatch()\"></a>store.dispatch()</h4><p>view想要更新数据state的唯一方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: types.LIST,</span><br><span class=\"line\">  data: res</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>dispatch接受的参数是action。当view层调用dispatch以后，store会根据type: types.LIST的值来判断调用那个一个具体的Reducer。这一步store怎么知道有哪些Reducers是可以搜索的呢，其实是因为，所有的Reducers都经过createStore()处理。具体的细节我还会再写一篇关于原理的笔记。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var store = createStore(Reducers);</span><br></pre></td></tr></table></figure>\n<h4 id=\"store-subscribe\"><a href=\"#store-subscribe\" class=\"headerlink\" title=\"store.subscribe()\"></a>store.subscribe()</h4><p>添加监听函数,这些函数会在每次dispatch action的时候调用，比如react就是把render()加入监听函数列表,这样每次dispatch action都会触发render()，重新渲染页面。</p>\n<h4 id=\"store-getState\"><a href=\"#store-getState\" class=\"headerlink\" title=\"store.getState()\"></a>store.getState()</h4><p>返回当前的state</p>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p><code>Store</code>对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照。这种快照，就叫做 State。</p>\n<p>当前时刻的 State，可以通过<code>store.getState()</code>拿到。State也是一个对象。一个State对应一个view，所以相同的State就会有相同的view。有一种说法，可以理解为state是数据流，随着时间移动，某部分state的数据会改变，而view就是state改变的体现。就像是ps中，你的每个操作都会生成一个历史记录，操作前是上一个state的快照，操作后是当前state快照，你的操作就是action。</p>\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>action是唯一可以改变state的方法。state的改变会导致view层的改变。redux的设计就是希望所有对state的修改都只能通过action来触发。所以action是view层想要改变的唯一方法。action是一个对象，其中type是必须的，表示触发哪个action。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: types.LIST,</span><br><span class=\"line\">  data: res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p>首先，reducer是一个方法，这个方法可以接受两个参数，一个是当前的state，一个是触发的action。</p>\n<p>reducer就是最后定义新state返回的函数，这个函数会根据不同的action，返回新的state。随着state的更新，view就也发生了更新。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reducerA =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    state = state || initState;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> LIST:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">          tableData: action.data</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DETAIL:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">          detailData: action.data</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>reducer有个非常重要的属性，就是它是一个<strong>纯函数</strong>。纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出，并且不修改原来的state，只是反回新的state。redux会根据新旧state的引用地址否相同来判断是否更新state。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>看了上面的基本概念，在看工作流程的那张图，感觉好像明白了一些，接下来，看看实际中，怎么运用。</p>\n<p>看看图中大致的流程，view层可以触发很多action，这些action可以按照时间顺序修改store中的state，state改变就可以触发view改变。</p>\n<h4 id=\"第一步-生成reducers\"><a href=\"#第一步-生成reducers\" class=\"headerlink\" title=\"第一步 生成reducers\"></a>第一步 生成reducers</h4><p>最直观的想，第一步是view层触发action，而文档中说明只有store.dispatch()触发action，所以，store是所有的根本。怎么生成store？</p>\n<p>前面说过，只需要引入redux，调用 createStore方法，传入reducers。</p>\n<p>reducer是一个方法，如reducer一节例子那样。但是如何项目有无数action，那么就会有无数的case来处理，这样的话，reducer可能有上千行，导致代码很难维护。所有我们需要将reducer按照功能模块进行拆分。</p>\n<p>假如把reducer一节例子分成两个功能模块：A 和B。</p>\n<p>那么reducerA是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  state = state || initState;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LIST:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">        tableData: action.data</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducerB是这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  state = state || initState;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DETAIL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">        tableData: action.data</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把两个reducer用<strong>combineReducers</strong> 组合起来。</p>\n<p><code>combineReducers</code> 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducers 函数，然后就可以对这个 reducers调用 <a href=\"http://cn.redux.js.org/docs/api/createStore.html\" target=\"_blank\" rel=\"noopener\"><code>createStore</code></a> 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerA <span class=\"keyword\">from</span> <span class=\"string\">'./reducerA'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerB <span class=\"keyword\">from</span> <span class=\"string\">'./reducerB'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> combineReducers(&#123;</span><br><span class=\"line\">  A: reducerA,</span><br><span class=\"line\">  B: reducerB</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>也可以直接这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerA <span class=\"keyword\">from</span> <span class=\"string\">'./reducerA'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerB <span class=\"keyword\">from</span> <span class=\"string\">'./reducerB'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> combineReducers(&#123;</span><br><span class=\"line\">  reducerA,</span><br><span class=\"line\">  reducerB</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>两种区别是上面一种可以重新命名state的变量名，下面这种默认state中变量名和reducer同名。</p>\n<p>合并后的 reducers 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 <strong>由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名</strong>。</p>\n<p>所以上面的例子对应的state就是下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; reducerA, reducerB &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就把一个大的reducer拆分成两个模块，并且在state中分别对应不同的变量。实际的项目中可能拆成很多模块，每个模块自己维护自己在state中的变量。</p>\n<h4 id=\"第二步-生成store\"><a href=\"#第二步-生成store\" class=\"headerlink\" title=\"第二步 生成store\"></a>第二步 生成store</h4><p>上面说了这么多就是为了能给<strong>createStore</strong> 方法造一个参数，reducers终于参数造好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./reducer'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducers);</span><br></pre></td></tr></table></figure>\n<p>有了store，就可以使用store的三个方法，dispatch，subscribe和getState。</p>\n<h4 id=\"第三步-dispatch-action\"><a href=\"#第三步-dispatch-action\" class=\"headerlink\" title=\"第三步 dispatch action\"></a>第三步 dispatch action</h4><p>看起来好像是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &apos;Learn Redux&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然鹅，实际的运用中，根本不是这样。</p>\n<p>实际的action并不是写成{ type: ‘ADD_TODO’, payload: ‘Learn Redux’}这样，而是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getList = <span class=\"function\">(<span class=\"params\">data, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: types.GET_LIST_COMPLETE,</span><br><span class=\"line\">    params: params</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createAccount = <span class=\"function\">(<span class=\"params\">data, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: types.TEST_CREATE_ACCOUNT,</span><br><span class=\"line\">    params: params</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过一个方法来返回这个action。</p>\n<p>这样做的目的是，可以调用<strong>bindActionCreators</strong> 方法，该方法的返回值是一个对象，可以通过对象的值直接调用dispatch(action)(隐式调用）。所以在实际的运用中并没有到处都是store.dispatch()。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action = bindActionCreators(actions, dispatch); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回值action</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  getList:  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(&#123; <span class=\"attr\">type</span>: types.GET_LIST_COMPLETE, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">  &#125;，</span><br><span class=\"line\">  createAccount:  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候只要使用action.getList()就可以触发action。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action.getList()</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">(funciton()&#123;</span><br><span class=\"line\">\tdispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">funcion getList ()&#123;</span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getList();</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"reducer为什么必须是纯函数\"><a href=\"#reducer为什么必须是纯函数\" class=\"headerlink\" title=\"reducer为什么必须是纯函数?\"></a>reducer为什么必须是<strong>纯函数</strong>?</h3><ul>\n<li><p>首先纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出。</p>\n<p>redux的store中数据是随着时间不断变化的，如果所有的reducer都是纯函数，那么state的每一步变化都，可以用前一个state和后一个state进行还原，有利于测试。</p>\n</li>\n<li><p>再次，纯函数不修改外部变量，只依赖入参，每次执行action以后，不修改原来的state，只是反回新的state。</p>\n<p>为什么这么做？来看看combineReducers方法中的源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br><span class=\"line\">   <span class=\"comment\">// 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">     <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">     <span class=\"comment\">// 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">     <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">     <span class=\"comment\">// 如果reducer返回undefined则抛出错误</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 将reducer返回的值填入nextState</span></span><br><span class=\"line\">     nextState[key] = nextStateForKey</span><br><span class=\"line\">     <span class=\"comment\">// 如果任一state有更新则hasChanged为true</span></span><br><span class=\"line\">     hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure>\n<p>看倒数第二行<code>hasChanged = hasChanged || nextStateForKey !== previousStateForKey</code> 最终判断是不是发生变化返回的是<code>nextStateForKey !== previousStateForKey</code> ，也就是说比较的是两个state的引用是不是同一个。如果reducer返回不是一个新的state，那么这里的引用是同一个，就不会更新store。</p>\n<p>在js中的对象有两种比较，一种是简单的引用比较，就是比较两个值的的引用地址是不是同一个，浅比较；还有一种比较两个js对象所有的属性是否相同也叫深比较。深比较由于需要层层循环对象来比较，对比的次数很多，开销非常大。</p>\n<p>reducer这里正好利用了纯函数的优点，每个reducer最后都返回一个新对象，这样可以用过简单的引用比较（!==）判断是否更新，节约了代码运行成本。可以说是设计的精髓所在。</p>\n</li>\n</ul>\n<h3 id=\"纯函数式编程优缺点\"><a href=\"#纯函数式编程优缺点\" class=\"headerlink\" title=\"纯函数式编程优缺点\"></a>纯函数式编程优缺点</h3><p>上面说到了纯函数，不由得让人想起纯函数编程。</p>\n<h4 id=\"什么是纯函数编程\"><a href=\"#什么是纯函数编程\" class=\"headerlink\" title=\"什么是纯函数编程\"></a>什么是纯函数编程</h4><p>我的理解，<code>纯函数编程</code> 是一种编程规范，就像<code>面向对象编程</code> 一样。主要思路是把运算过程尽量写成一系列嵌套的函数调用。</p>\n<h4 id=\"有什么特点\"><a href=\"#有什么特点\" class=\"headerlink\" title=\"有什么特点\"></a>有什么特点</h4><ul>\n<li><strong>函数只是普通对象</strong>  函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>\n<li><strong>只用”表达式”，不用”语句”</strong> 不做赋值的操作</li>\n<li><strong>没有”副作用”</strong> 由于纯函数只依赖输入的参数，所以只要相同的输入一定能得到相同的结果</li>\n<li><strong>不修改状态</strong> 函数式编程只是返回新的值，不修改系统变量。</li>\n</ul>\n<p>这样就可以得出纯函数基本的原则：</p>\n<ul>\n<li>不得改写参数</li>\n<li>不能调用系统 I/O 的API</li>\n<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>\n</ul>\n<h4 id=\"有什么优点\"><a href=\"#有什么优点\" class=\"headerlink\" title=\"有什么优点\"></a>有什么优点</h4><ul>\n<li><strong>代码简洁，开发快速</strong>  函数式编程进而可以写成链式，代码简介</li>\n<li><strong>易于”并发编程”</strong>  由于代码的执行只和输入的参数有关，和先后顺序无关，所以没有锁等问题</li>\n<li><strong>代码的热升级</strong> </li>\n<li><strong>易于测试</strong>  只要给出同样的输入，就一定会得到相同结果，易于功能测试</li>\n</ul>\n<p>具体还可以参看这篇文章：<a href=\"http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p>\n<h4 id=\"有什么缺点\"><a href=\"#有什么缺点\" class=\"headerlink\" title=\"有什么缺点\"></a>有什么缺点</h4><ul>\n<li><p><strong>代码很难读懂，入门困难</strong> </p>\n</li>\n<li><p><strong>很多地方使用了递归，导致函数式语言的运行速度比较慢</strong> </p>\n</li>\n<li><p><strong>方法不能继承，即使很相似的方法也得重新编写。</strong> </p>\n</li>\n<li><p><strong>面向对象编程的优点“封装”“继承”“多态”就是纯函数编程的缺点。</strong></p>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redux理解和应用\"><a href=\"#Redux理解和应用\" class=\"headerlink\" title=\"Redux理解和应用\"></a>Redux理解和应用</h1><blockquote>\n<p>写在前面：说到redux就不得不说react，之前做过一个项目是纯用react的，所有的数据都使用props和state来管理。无赖后来没有等到项目引进redux就终止了。那时候觉得没有使用redux，react也能自己很好的管理自己的数据，组件之间的通信仅仅是通过props或者回调函数来完成（组件之间的通信参看<a href=\"https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。\" target=\"_blank\" rel=\"noopener\">https://www.javascriptstuff.com/component-communication/）。后来另一个项目中使用了redux，感觉如果当初的业务在复杂一些，比如组件中很多3层组件的情况，并且这些组件之间有复杂的通信，那么单单使用react可能就比较吃力了。</a></p>\n</blockquote>\n<h2 id=\"Redux解决了什么问题\"><a href=\"#Redux解决了什么问题\" class=\"headerlink\" title=\"Redux解决了什么问题\"></a>Redux解决了什么问题</h2><p>redux是一种解决方案。react只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。redux并不是必须要用的。但是当组件之间涉及到下面的场景，就需要引入redux。</p>\n<ul>\n<li>某个组件的状态，需要共享</li>\n<li>某个状态需要在任何地方都可以拿到</li>\n<li>一个组件需要改变全局状态</li>\n<li>一个组件需要改变另一个组件的状态</li>\n</ul>\n<p>发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。</p>\n<h2 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h2><p>在接触mvvm的框架的时候会有一些感觉，我们是通过改变数据来改变视图的，因为mvvm框架通常是双向绑定的。react是单向数据流，我们也可以通过某种手段使得同样的数据对应同样的视图。redux的设计理念就是，所有的数据都由store来管理。所有的变动都由action来发起。当view层发起一个action以后，最后由reducers来执行，reducers是一个纯函数，也就是说，只要是同样的输入，必定得到同样的输出。经过reducer处理返回新的state更新到store中。这样的流程使得所有的数据更新都要通过这个流程。</p>\n<p>可以理解为一个所有的组件都共用一个store，这样，第一小节中提到的：组件的状态，需要共享；某个状态需要在任何地方都可以拿到；一个组件需要改变全局状态；一个组件需要改变另一个组件的状态等组件之间的通行或者跨页面之间的共享问题就得到解决。</p>\n<p>有了redux的规范，项目的文件也会更加清晰，同时也提升了开发体验</p>\n<h2 id=\"Redux工作流程\"><a href=\"#Redux工作流程\" class=\"headerlink\" title=\"Redux工作流程\"></a>Redux工作流程</h2><p><img src=\"/2018/04/09/Redux理解和应用/redux.png\" alt=\"Redux工作流程\"></p>\n<p>整个工作流程是，view层触发action，store更具action找到对应的reducer，并将当前state和action传给reducer，reducer处理完数据以后返回新的state，view层根据新的state更新视图。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store 就是保存数据的一个对象，一个容器。整个应用有一个 Store。</p>\n<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>\n<p>参数reducer是个function如下，传入两个参数，一个是初始State，一个是action</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reducer= <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> state;</span><br></pre></td></tr></table></figure>\n<p>最终，store是一个类似这样的对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = &#123;</span><br><span class=\"line\">  currentState: initialState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123; currentState = reducer(currentState, action)&#125;,</span><br><span class=\"line\">  getState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> currentState,</span><br><span class=\"line\">  subscribe: <span class=\"function\"><span class=\"params\">()</span> = (<span class=\"params\">listener</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    listeners.push(listener);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      listeners = listeners.filter(<span class=\"function\"><span class=\"params\">l</span> =&gt;</span> l !== listener);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个对象返回三个方法，dispatch，subscribe和getState，dispatch触发以后会修改state，getState会返回当前的state。</p>\n<h4 id=\"store-dispatch\"><a href=\"#store-dispatch\" class=\"headerlink\" title=\"store.dispatch()\"></a>store.dispatch()</h4><p>view想要更新数据state的唯一方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: types.LIST,</span><br><span class=\"line\">  data: res</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>dispatch接受的参数是action。当view层调用dispatch以后，store会根据type: types.LIST的值来判断调用那个一个具体的Reducer。这一步store怎么知道有哪些Reducers是可以搜索的呢，其实是因为，所有的Reducers都经过createStore()处理。具体的细节我还会再写一篇关于原理的笔记。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var store = createStore(Reducers);</span><br></pre></td></tr></table></figure>\n<h4 id=\"store-subscribe\"><a href=\"#store-subscribe\" class=\"headerlink\" title=\"store.subscribe()\"></a>store.subscribe()</h4><p>添加监听函数,这些函数会在每次dispatch action的时候调用，比如react就是把render()加入监听函数列表,这样每次dispatch action都会触发render()，重新渲染页面。</p>\n<h4 id=\"store-getState\"><a href=\"#store-getState\" class=\"headerlink\" title=\"store.getState()\"></a>store.getState()</h4><p>返回当前的state</p>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p><code>Store</code>对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照。这种快照，就叫做 State。</p>\n<p>当前时刻的 State，可以通过<code>store.getState()</code>拿到。State也是一个对象。一个State对应一个view，所以相同的State就会有相同的view。有一种说法，可以理解为state是数据流，随着时间移动，某部分state的数据会改变，而view就是state改变的体现。就像是ps中，你的每个操作都会生成一个历史记录，操作前是上一个state的快照，操作后是当前state快照，你的操作就是action。</p>\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>action是唯一可以改变state的方法。state的改变会导致view层的改变。redux的设计就是希望所有对state的修改都只能通过action来触发。所以action是view层想要改变的唯一方法。action是一个对象，其中type是必须的，表示触发哪个action。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: types.LIST,</span><br><span class=\"line\">  data: res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p>首先，reducer是一个方法，这个方法可以接受两个参数，一个是当前的state，一个是触发的action。</p>\n<p>reducer就是最后定义新state返回的函数，这个函数会根据不同的action，返回新的state。随着state的更新，view就也发生了更新。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reducerA =  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    state = state || initState;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> LIST:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">          tableData: action.data</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> DETAIL:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">          detailData: action.data</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>reducer有个非常重要的属性，就是它是一个<strong>纯函数</strong>。纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出，并且不修改原来的state，只是反回新的state。redux会根据新旧state的引用地址否相同来判断是否更新state。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>看了上面的基本概念，在看工作流程的那张图，感觉好像明白了一些，接下来，看看实际中，怎么运用。</p>\n<p>看看图中大致的流程，view层可以触发很多action，这些action可以按照时间顺序修改store中的state，state改变就可以触发view改变。</p>\n<h4 id=\"第一步-生成reducers\"><a href=\"#第一步-生成reducers\" class=\"headerlink\" title=\"第一步 生成reducers\"></a>第一步 生成reducers</h4><p>最直观的想，第一步是view层触发action，而文档中说明只有store.dispatch()触发action，所以，store是所有的根本。怎么生成store？</p>\n<p>前面说过，只需要引入redux，调用 createStore方法，传入reducers。</p>\n<p>reducer是一个方法，如reducer一节例子那样。但是如何项目有无数action，那么就会有无数的case来处理，这样的话，reducer可能有上千行，导致代码很难维护。所有我们需要将reducer按照功能模块进行拆分。</p>\n<p>假如把reducer一节例子分成两个功能模块：A 和B。</p>\n<p>那么reducerA是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  state = state || initState;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LIST:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">        tableData: action.data</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducerB是这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  state = state || initState;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DETAIL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(state, &#123;</span><br><span class=\"line\">        tableData: action.data</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把两个reducer用<strong>combineReducers</strong> 组合起来。</p>\n<p><code>combineReducers</code> 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducers 函数，然后就可以对这个 reducers调用 <a href=\"http://cn.redux.js.org/docs/api/createStore.html\" target=\"_blank\" rel=\"noopener\"><code>createStore</code></a> 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerA <span class=\"keyword\">from</span> <span class=\"string\">'./reducerA'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerB <span class=\"keyword\">from</span> <span class=\"string\">'./reducerB'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> combineReducers(&#123;</span><br><span class=\"line\">  A: reducerA,</span><br><span class=\"line\">  B: reducerB</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>也可以直接这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerA <span class=\"keyword\">from</span> <span class=\"string\">'./reducerA'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducerB <span class=\"keyword\">from</span> <span class=\"string\">'./reducerB'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> combineReducers(&#123;</span><br><span class=\"line\">  reducerA,</span><br><span class=\"line\">  reducerB</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>两种区别是上面一种可以重新命名state的变量名，下面这种默认state中变量名和reducer同名。</p>\n<p>合并后的 reducers 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 <strong>由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名</strong>。</p>\n<p>所以上面的例子对应的state就是下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; reducerA, reducerB &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就把一个大的reducer拆分成两个模块，并且在state中分别对应不同的变量。实际的项目中可能拆成很多模块，每个模块自己维护自己在state中的变量。</p>\n<h4 id=\"第二步-生成store\"><a href=\"#第二步-生成store\" class=\"headerlink\" title=\"第二步 生成store\"></a>第二步 生成store</h4><p>上面说了这么多就是为了能给<strong>createStore</strong> 方法造一个参数，reducers终于参数造好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">'./reducer'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducers);</span><br></pre></td></tr></table></figure>\n<p>有了store，就可以使用store的三个方法，dispatch，subscribe和getState。</p>\n<h4 id=\"第三步-dispatch-action\"><a href=\"#第三步-dispatch-action\" class=\"headerlink\" title=\"第三步 dispatch action\"></a>第三步 dispatch action</h4><p>看起来好像是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &apos;Learn Redux&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然鹅，实际的运用中，根本不是这样。</p>\n<p>实际的action并不是写成{ type: ‘ADD_TODO’, payload: ‘Learn Redux’}这样，而是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getList = <span class=\"function\">(<span class=\"params\">data, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: types.GET_LIST_COMPLETE,</span><br><span class=\"line\">    params: params</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createAccount = <span class=\"function\">(<span class=\"params\">data, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: types.TEST_CREATE_ACCOUNT,</span><br><span class=\"line\">    params: params</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过一个方法来返回这个action。</p>\n<p>这样做的目的是，可以调用<strong>bindActionCreators</strong> 方法，该方法的返回值是一个对象，可以通过对象的值直接调用dispatch(action)(隐式调用）。所以在实际的运用中并没有到处都是store.dispatch()。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action = bindActionCreators(actions, dispatch); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回值action</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  getList:  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(&#123; <span class=\"attr\">type</span>: types.GET_LIST_COMPLETE, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">  &#125;，</span><br><span class=\"line\">  createAccount:  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候只要使用action.getList()就可以触发action。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action.getList()</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">(funciton()&#123;</span><br><span class=\"line\">\tdispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">funcion getList ()&#123;</span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: types.TEST_CREATE_ACCOUNT, <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getList();</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"reducer为什么必须是纯函数\"><a href=\"#reducer为什么必须是纯函数\" class=\"headerlink\" title=\"reducer为什么必须是纯函数?\"></a>reducer为什么必须是<strong>纯函数</strong>?</h3><ul>\n<li><p>首先纯函数只用表达式不用语句，可以保证相同的输入，必定得到同样的输出。</p>\n<p>redux的store中数据是随着时间不断变化的，如果所有的reducer都是纯函数，那么state的每一步变化都，可以用前一个state和后一个state进行还原，有利于测试。</p>\n</li>\n<li><p>再次，纯函数不修改外部变量，只依赖入参，每次执行action以后，不修改原来的state，只是反回新的state。</p>\n<p>为什么这么做？来看看combineReducers方法中的源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br><span class=\"line\">   <span class=\"comment\">// 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">     <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">     <span class=\"comment\">// 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">     <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">     <span class=\"comment\">// 如果reducer返回undefined则抛出错误</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 将reducer返回的值填入nextState</span></span><br><span class=\"line\">     nextState[key] = nextStateForKey</span><br><span class=\"line\">     <span class=\"comment\">// 如果任一state有更新则hasChanged为true</span></span><br><span class=\"line\">     hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure>\n<p>看倒数第二行<code>hasChanged = hasChanged || nextStateForKey !== previousStateForKey</code> 最终判断是不是发生变化返回的是<code>nextStateForKey !== previousStateForKey</code> ，也就是说比较的是两个state的引用是不是同一个。如果reducer返回不是一个新的state，那么这里的引用是同一个，就不会更新store。</p>\n<p>在js中的对象有两种比较，一种是简单的引用比较，就是比较两个值的的引用地址是不是同一个，浅比较；还有一种比较两个js对象所有的属性是否相同也叫深比较。深比较由于需要层层循环对象来比较，对比的次数很多，开销非常大。</p>\n<p>reducer这里正好利用了纯函数的优点，每个reducer最后都返回一个新对象，这样可以用过简单的引用比较（!==）判断是否更新，节约了代码运行成本。可以说是设计的精髓所在。</p>\n</li>\n</ul>\n<h3 id=\"纯函数式编程优缺点\"><a href=\"#纯函数式编程优缺点\" class=\"headerlink\" title=\"纯函数式编程优缺点\"></a>纯函数式编程优缺点</h3><p>上面说到了纯函数，不由得让人想起纯函数编程。</p>\n<h4 id=\"什么是纯函数编程\"><a href=\"#什么是纯函数编程\" class=\"headerlink\" title=\"什么是纯函数编程\"></a>什么是纯函数编程</h4><p>我的理解，<code>纯函数编程</code> 是一种编程规范，就像<code>面向对象编程</code> 一样。主要思路是把运算过程尽量写成一系列嵌套的函数调用。</p>\n<h4 id=\"有什么特点\"><a href=\"#有什么特点\" class=\"headerlink\" title=\"有什么特点\"></a>有什么特点</h4><ul>\n<li><strong>函数只是普通对象</strong>  函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>\n<li><strong>只用”表达式”，不用”语句”</strong> 不做赋值的操作</li>\n<li><strong>没有”副作用”</strong> 由于纯函数只依赖输入的参数，所以只要相同的输入一定能得到相同的结果</li>\n<li><strong>不修改状态</strong> 函数式编程只是返回新的值，不修改系统变量。</li>\n</ul>\n<p>这样就可以得出纯函数基本的原则：</p>\n<ul>\n<li>不得改写参数</li>\n<li>不能调用系统 I/O 的API</li>\n<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>\n</ul>\n<h4 id=\"有什么优点\"><a href=\"#有什么优点\" class=\"headerlink\" title=\"有什么优点\"></a>有什么优点</h4><ul>\n<li><strong>代码简洁，开发快速</strong>  函数式编程进而可以写成链式，代码简介</li>\n<li><strong>易于”并发编程”</strong>  由于代码的执行只和输入的参数有关，和先后顺序无关，所以没有锁等问题</li>\n<li><strong>代码的热升级</strong> </li>\n<li><strong>易于测试</strong>  只要给出同样的输入，就一定会得到相同结果，易于功能测试</li>\n</ul>\n<p>具体还可以参看这篇文章：<a href=\"http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p>\n<h4 id=\"有什么缺点\"><a href=\"#有什么缺点\" class=\"headerlink\" title=\"有什么缺点\"></a>有什么缺点</h4><ul>\n<li><p><strong>代码很难读懂，入门困难</strong> </p>\n</li>\n<li><p><strong>很多地方使用了递归，导致函数式语言的运行速度比较慢</strong> </p>\n</li>\n<li><p><strong>方法不能继承，即使很相似的方法也得重新编写。</strong> </p>\n</li>\n<li><p><strong>面向对象编程的优点“封装”“继承”“多态”就是纯函数编程的缺点。</strong></p>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"前端单页系统的权限控制","date":"2018-11-28T07:02:39.000Z","_content":"\n# 前端单页系统的权限控制\n\n> 写在前面：说到权限的控制，前端的权限是不安全的。所有的权限应该都由后端来做才能保证安全。那么我们为什么要在前端做权限控制呢？答案很简单，为了用户体验。一个普通用户明明看到了一个路由，点击以后系统报错说没有权限的体验，远远不如用户一开始并没有看到这个路由。这就是前端做权限控制的意义。也就是说，前端只负责把有权限的页面或者按钮展示给用户，其他的隐藏起来。前端单页的应用大大提升了前端权限控制的需求。很多后台管理系统都是单页应用，也都需要权限控制，这样不同的角色可以进行不同的操作。我所做的项目也是如此。这里将react和react-router等相关的类容一起总结一下。\n\n\n\n### 前端的权限的维度\n\n经验统计，前端权限的体现主要有以下3种类型：\n\n* **路由** \n\n  最常见的就是菜单栏或者导航栏的控制，不同的用户看到的菜单栏不一样，比如登录某云的后台管理系统，发现导航栏有2个下拉的选项，而管理员登录却能看到十几二十个下拉选项。这样的权限，通常是针对整个页面的，也就是设计者希望没有权限的人整个页面都看不到。就算使用者知道页面的路由，进去以后依然什么也看不见。\n\n* **按钮** \n\n  同样的页面，可以操作的按钮不一样，比如登录某云的后台管理系统，一个工单，普通用户只看到“查看”按钮，但是管理员就能看到“查看”，“审批”两个按钮。这样的权限，通常是希望使用者能看到页面，但是页面上的某些操作不能操作。\n\n* **请求** \n\n  请求，是前端权限的最后一次拦截。就是即将要发出请求的时候对权限进行检验，如果没有权限则不发送这个请求。\n\n以上3种形式组成了前端权限的控制。\n\n\n\n### 实现思路\n\n上面说到权限的3中体现，这里说明下针对这3种情况的实现思路\n\n#### 路由\n\n初始化路由之前就拿到权限的列表，再进行初始化，直接根据权限，初始化相应的路由。\n\n#### 页面和按钮\n\n后端对于实现权限、日志等功能都是借用AOP面向切面的思想来实现。面向切面的思想把一些与核心业务无关，但任何模块都可能使用的功能抽离出来，然后动态给业务模块添加上需要的功能。然鹅，前端并没有实现动态添加业务模块的机制，不过仍然可以参考这个思想。我们把与权限有关的抽离成一个公用的组件，在需要使用权限的地方初始化这个组件，这个组件的插入尽量做到不影响页面的原有逻辑。\n\n#### 请求\n\n可以写一个公用的方法，这个方法可以判断，当前的用户是否有这个接口的访问权限，如果有就发送请求，如果没有就不发送请求。\n\n\n\n## 实战\n\n上面说了实现的思路，下面就具体说下怎么做。以`react` + `react router` 为例。\n\n### react路由权限控制\n\n想要路由渲染的时候根据权限来进行渲染，那在初始化路由之前就应该拿到权限的列表。因此所有内容都应该在权限加载完以后加载。\n\n```js\nimport ReactDOM, { render } from 'react-dom'\nimport React, { Component } from 'react'\nimport App from 'es/components/app'\nimport Permission from 'es/components/permission'\nimport Root from './root'\nimport { needPermissions as headPermissions } from '../../../permissions/es-header'\n\nclass MyAPP extends Component {\n  render () {\n    return (\n      <App>\n        <Permission\n          queryPermissions={headPermissions.concat(['ADMINGROUPS_GET_LIST'])}\n        >\n          <Root />\n        </Permission>\n      </App>\n    );\n  }\n}\n\nrender((<MyAPP />), document.getElementById('application'))\n```\n\n上面代码是页面的入口文件。可以看到，这个入口文件最外层组件是`App` 组件，其次是`Permission` 组件。 `Root` 组件就是页面真正的内容。为什么我们需要再最外层套两层呢？因为之前说的，我们在初始化路由的时候需要拿到用户的权限以及用户的信息，于是我们在`App` 组件获取到用户的信息，在`Permission` 组件中获取权限。这里可以根据各自的业务逻辑灵活使用，如果不需要用户的信息，可以直接只套一层。\n\n\n\n在上面两个组件中获取到了用户和权限信息，我们怎么传递给其他组价使用呢？react中，传递变量通常是用props一层层往下传，但是像用户信息和权限这类信息，在全局任何地方都有可能用到，如果使用props从顶层组价一层层往下传会显得非常繁琐，debug问题的时候也很难快速定位。有没有什么方法可以让这类信息像全局变量一样，任何一个自组件都能轻松的访问到呢？有一个非官方的方法`context` 。\n\n\n\n#####  Context——定义游离于组件之外的全局变量\n\ncontext的使用非常方便，只要在父组件或者说外层组件定义一个`getChildContext`方法和`childContextTypes ` 变量，在里层定义`contextTypes`就可以直接在里层用`this.context`访问。举个栗子：\n\n```js\nimport React, { Children, Component, ReactElement } from 'react';\nimport PropTypes from 'prop-types';\n\nimport request, { getApis } from 'es/utils/api-request';\nimport apis from 'es/constants/apis';\n\nexport default class Permission extends Component {\n  _queryPermissions: Array<string>\n\n  static childContextTypes = {\n    permissions: PropTypes.object,\n    hasPermissions: PropTypes.func,\n    hasSomePermissions: PropTypes.func\n  }\n\n  getChildContext () {\n    return {\n      permissions: this.state.permissions,\n      hasPermissions: this.hasPermissions.bind(this),\n      hasSomePermissions: this.hasSomePermissions.bind(this)\n    };\n  }\n\n  state = {\n    permissions: undefined\n  }\n\n  constructor (props, context) {\n    super(props, context);\n\n    const {needPermissions = [], needSomePermissions = [], queryPermissions = []\n    } = this.props;\n\n    this._queryPermissions = Array.from(\n      new Set([...queryPermissions, ...needPermissions, ...needSomePermissions]));\n  }\n\n  componentDidMount () {\n    /* 从后端获取权限并保存在state中*/\n    this.getPermissions();\n  }\n\t/* 判断当前用户是否具有传入的权限*/\n  hasPermissions (checkPermissions) {\n    let { permissions = {} } = this.state;\n    return !checkPermissions || checkPermissions.every((p) => permissions[p]);\n  }\n\t/* 判断当前用户是否具有传入的权限组*/\n  hasSomePermissions (checkPermissions) {\n    let { permissions = {} } = this.state;\n    return !checkPermissions || checkPermissions.some((p) => permissions[p]);\n  }\n\n  render () {\n    let { props } = this;\n    const {needPermissions, needSomePermissions, noPermissionChild } = props;\n\n    var child;\n\n    if (this.state.permissions) {\n      if (\n        (needPermissions && !this.hasPermissions(needPermissions)) ||\n        (needSomePermissions && !this.hasSomePermissions(needSomePermissions))\n      ) {\n        child = noPermissionChild;\n      } else {\n        child = props.children;\n      }\n    }\n\n    return child ? Children.only(child) : null;\n  }\n}\n```\n\n`Permission` 组件的主要功能就是，从后端获取所有的permissions，放在自己的state中，并通过context，将permissions以及几个方法存储在全局变量中，判断传入的权限名该用户是不是有，没有就显示没有权限，有就显示子组件。\n\n上面的组件和一般的组件没有什么差别，就是多定义了`getChildContext`方法和`childContextTypes ` 变量。\n\n如何在子组件中拿到permissions呢？\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Menu } from 'antd';\nimport { functionalModules, commonModules } from '../../../permissions/es-header';\n\nexport default class AppHeader extends Component {\n  static contextTypes = {\n    user: PropTypes.object,\n    hasSomePermissions: PropTypes.func\n  }\n\n  getUserName () {\n    let { user } = this.context;\n\n    return (\n      <Menu.SubMenu\n        title={(<span>{user.name}</span>)}\n      >\n      </Menu.SubMenu>\n    );\n  }\n\n  getProducts (modules) {\n    return modules.map((m) => (\n      this.checkAuth(m.apis)\n      ? (\n        <Menu.Item key={m.text}>\n          <a href={m.url}>{m.text}</a>\n        </Menu.Item>\n      )\n      : null\n    )).filter((item) => !!item);\n  }\n\n  checkAuth (apis) {\n    let { hasSomePermissions } = this.context;\n\n    if (apis) {\n      return hasSomePermissions(apis);\n    }\n    return hasSomePermissions(apis);\n  }\n\n  render () {\n    return (\n      <div>\n          <Menu>\n            <Menu.SubMenu title=\"功能1\">\n              <Menu.ItemGroup title=\"具体模块\">\n                {this.getProducts(functionalModules)}\n              </Menu.ItemGroup>\n            </Menu.SubMenu>\n          </Menu>\n          <Menu>\n            {this.getUserName()}\n          </Menu>\n\t\t</div>\n    )\n  }\n}\n\n```\n\n如上代码，只要在组件中定义`contextTypes` ，就能`this.context` 直接调用需要的变量或者方法。\n\n事实上，上面的代码就是路由权限控制的关键。我们把所有完整的路由以json的形式静态保存起来，`Menu.ItemGroup` 组件，渲染出来的就是根据用户的权限从完整路由中过滤出来的目录。\n\n```js\n[\n  {\n    \"apis\": [\n      \"GET_USER_LIST\",\n      \"ADD_USER_ITEM\"\n    ],\n    \"text\": \"用户管理\",\n    \"url\": \"/user\"\n  },\n  {\n    \"apis\": [\n      \"ADD_FEE_ITEM\",\n      \"GET_FEE_LIST\"\n    ],\n    \"text\": \"费用管理\",\n    \"url\": \"/fee\"\n  }\n]\n```\n\n这里实现的是一个很简单顶部。左侧导航栏也是同样的处理思路。\n\n其实上还有一种思路是将路由的组件进行封装，这个组件在挂载前判断是不是有权限，就是利用路由的回调函数`onEnter` ，`onLeave()` 来做。这里没有那样做的理由是，如果按照这种思路来做，那每个路由的回调都会执行一次，有些浪费资源。\n\n具体可以参看其他的文章：https://blog.csdn.net/qq_39985511/article/details/80885158\n\n\n\n### react页面和按钮权限控制\n\n在路由的实现中其实已经实现了`Permission` 组件，无论是页面，还是按钮，只要需要权限控制的地方，就在组件外层添加这个组件，并传入需要的权限名字，如果有权限，就初始化子组件，没有就不处理或者显示没有权限。\n\n一个页面的例子：\n\n```js\nexport default class MyPageContainer extends Component {\n  render () {\n    return (\n      <div>\n        <Breadcrumb routes={routes} params={allParams} />\n        <Permission\n          needPermissions={['GET_LIST']}\n          noPermissionChild={<span>无权限</span>}\n        >\n          <MyPage/>\n        </Permission>\n      </div>\n    )\n  }\n}\n```\n\n一个按钮的例子：\n\n```js\n  render () {\n    return (\n      <div>\n        <Permission\n          needPermissions={['ADD_ITEM']}\n        >\n          <Button>新增</Button>\n        </Permission>\n      </div>\n    );\n  }\n```\n\n\n\n### 发送请求时的权限\n\n这个基于前面的内容，在发送请求的时候再进行一次判断。`Permission` 组件返回了一些方法，可以通过context来获取到。同样这些方法可以判断当前用户是不是拥有该接口的权限。如果拥有就发送请求，否则就不发送。我们可以将发送请求的方法提取出来一并处理。但是我们必须在前端维护一个接口和对应权限名称的文件。这样才能知道哪个接口需要的是什么权限。类似于下面这样。\n\n```js\n{\n  \"URSUSER_GET_LIST\": {\n    \"url\": \"/users/info\",\n    \"method\": \"GET\",\n    \"action\": \"searchUserInfo\",\n    \"resource\": \"/users/info\"\n  },\n  \"URSUSER_MODIFY\": {\n    \"url\": \"/users/modify\",\n    \"method\": \"POST\",\n    \"action\": \"modifyUserInfo\",\n    \"resource\": \"/users/modify\"\n  }\n}\n```\n\n\n\n### 总结\n\n有关权限的控制，都应该由后端来做。前端只是为了提高用户体验，让没有权限的资源不显示出来。前端的控制的主要思路就是有一个公用的方法，这个方法可以判断当前用户是不是拥有需要的权限，然后前端根据这个方法返回的结构生成路由，渲染页面等。\n\n\n\n其他参考文章：\n\nhttps://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/\n","source":"_posts/前端单页系统的权限控制.md","raw":"---\ntitle: 前端单页系统的权限控制\ndate: 2018-11-28 15:02:39\ntags:\n- 前端\n- js\n- 单页\n- 路由\n- 权限\n---\n\n# 前端单页系统的权限控制\n\n> 写在前面：说到权限的控制，前端的权限是不安全的。所有的权限应该都由后端来做才能保证安全。那么我们为什么要在前端做权限控制呢？答案很简单，为了用户体验。一个普通用户明明看到了一个路由，点击以后系统报错说没有权限的体验，远远不如用户一开始并没有看到这个路由。这就是前端做权限控制的意义。也就是说，前端只负责把有权限的页面或者按钮展示给用户，其他的隐藏起来。前端单页的应用大大提升了前端权限控制的需求。很多后台管理系统都是单页应用，也都需要权限控制，这样不同的角色可以进行不同的操作。我所做的项目也是如此。这里将react和react-router等相关的类容一起总结一下。\n\n\n\n### 前端的权限的维度\n\n经验统计，前端权限的体现主要有以下3种类型：\n\n* **路由** \n\n  最常见的就是菜单栏或者导航栏的控制，不同的用户看到的菜单栏不一样，比如登录某云的后台管理系统，发现导航栏有2个下拉的选项，而管理员登录却能看到十几二十个下拉选项。这样的权限，通常是针对整个页面的，也就是设计者希望没有权限的人整个页面都看不到。就算使用者知道页面的路由，进去以后依然什么也看不见。\n\n* **按钮** \n\n  同样的页面，可以操作的按钮不一样，比如登录某云的后台管理系统，一个工单，普通用户只看到“查看”按钮，但是管理员就能看到“查看”，“审批”两个按钮。这样的权限，通常是希望使用者能看到页面，但是页面上的某些操作不能操作。\n\n* **请求** \n\n  请求，是前端权限的最后一次拦截。就是即将要发出请求的时候对权限进行检验，如果没有权限则不发送这个请求。\n\n以上3种形式组成了前端权限的控制。\n\n\n\n### 实现思路\n\n上面说到权限的3中体现，这里说明下针对这3种情况的实现思路\n\n#### 路由\n\n初始化路由之前就拿到权限的列表，再进行初始化，直接根据权限，初始化相应的路由。\n\n#### 页面和按钮\n\n后端对于实现权限、日志等功能都是借用AOP面向切面的思想来实现。面向切面的思想把一些与核心业务无关，但任何模块都可能使用的功能抽离出来，然后动态给业务模块添加上需要的功能。然鹅，前端并没有实现动态添加业务模块的机制，不过仍然可以参考这个思想。我们把与权限有关的抽离成一个公用的组件，在需要使用权限的地方初始化这个组件，这个组件的插入尽量做到不影响页面的原有逻辑。\n\n#### 请求\n\n可以写一个公用的方法，这个方法可以判断，当前的用户是否有这个接口的访问权限，如果有就发送请求，如果没有就不发送请求。\n\n\n\n## 实战\n\n上面说了实现的思路，下面就具体说下怎么做。以`react` + `react router` 为例。\n\n### react路由权限控制\n\n想要路由渲染的时候根据权限来进行渲染，那在初始化路由之前就应该拿到权限的列表。因此所有内容都应该在权限加载完以后加载。\n\n```js\nimport ReactDOM, { render } from 'react-dom'\nimport React, { Component } from 'react'\nimport App from 'es/components/app'\nimport Permission from 'es/components/permission'\nimport Root from './root'\nimport { needPermissions as headPermissions } from '../../../permissions/es-header'\n\nclass MyAPP extends Component {\n  render () {\n    return (\n      <App>\n        <Permission\n          queryPermissions={headPermissions.concat(['ADMINGROUPS_GET_LIST'])}\n        >\n          <Root />\n        </Permission>\n      </App>\n    );\n  }\n}\n\nrender((<MyAPP />), document.getElementById('application'))\n```\n\n上面代码是页面的入口文件。可以看到，这个入口文件最外层组件是`App` 组件，其次是`Permission` 组件。 `Root` 组件就是页面真正的内容。为什么我们需要再最外层套两层呢？因为之前说的，我们在初始化路由的时候需要拿到用户的权限以及用户的信息，于是我们在`App` 组件获取到用户的信息，在`Permission` 组件中获取权限。这里可以根据各自的业务逻辑灵活使用，如果不需要用户的信息，可以直接只套一层。\n\n\n\n在上面两个组件中获取到了用户和权限信息，我们怎么传递给其他组价使用呢？react中，传递变量通常是用props一层层往下传，但是像用户信息和权限这类信息，在全局任何地方都有可能用到，如果使用props从顶层组价一层层往下传会显得非常繁琐，debug问题的时候也很难快速定位。有没有什么方法可以让这类信息像全局变量一样，任何一个自组件都能轻松的访问到呢？有一个非官方的方法`context` 。\n\n\n\n#####  Context——定义游离于组件之外的全局变量\n\ncontext的使用非常方便，只要在父组件或者说外层组件定义一个`getChildContext`方法和`childContextTypes ` 变量，在里层定义`contextTypes`就可以直接在里层用`this.context`访问。举个栗子：\n\n```js\nimport React, { Children, Component, ReactElement } from 'react';\nimport PropTypes from 'prop-types';\n\nimport request, { getApis } from 'es/utils/api-request';\nimport apis from 'es/constants/apis';\n\nexport default class Permission extends Component {\n  _queryPermissions: Array<string>\n\n  static childContextTypes = {\n    permissions: PropTypes.object,\n    hasPermissions: PropTypes.func,\n    hasSomePermissions: PropTypes.func\n  }\n\n  getChildContext () {\n    return {\n      permissions: this.state.permissions,\n      hasPermissions: this.hasPermissions.bind(this),\n      hasSomePermissions: this.hasSomePermissions.bind(this)\n    };\n  }\n\n  state = {\n    permissions: undefined\n  }\n\n  constructor (props, context) {\n    super(props, context);\n\n    const {needPermissions = [], needSomePermissions = [], queryPermissions = []\n    } = this.props;\n\n    this._queryPermissions = Array.from(\n      new Set([...queryPermissions, ...needPermissions, ...needSomePermissions]));\n  }\n\n  componentDidMount () {\n    /* 从后端获取权限并保存在state中*/\n    this.getPermissions();\n  }\n\t/* 判断当前用户是否具有传入的权限*/\n  hasPermissions (checkPermissions) {\n    let { permissions = {} } = this.state;\n    return !checkPermissions || checkPermissions.every((p) => permissions[p]);\n  }\n\t/* 判断当前用户是否具有传入的权限组*/\n  hasSomePermissions (checkPermissions) {\n    let { permissions = {} } = this.state;\n    return !checkPermissions || checkPermissions.some((p) => permissions[p]);\n  }\n\n  render () {\n    let { props } = this;\n    const {needPermissions, needSomePermissions, noPermissionChild } = props;\n\n    var child;\n\n    if (this.state.permissions) {\n      if (\n        (needPermissions && !this.hasPermissions(needPermissions)) ||\n        (needSomePermissions && !this.hasSomePermissions(needSomePermissions))\n      ) {\n        child = noPermissionChild;\n      } else {\n        child = props.children;\n      }\n    }\n\n    return child ? Children.only(child) : null;\n  }\n}\n```\n\n`Permission` 组件的主要功能就是，从后端获取所有的permissions，放在自己的state中，并通过context，将permissions以及几个方法存储在全局变量中，判断传入的权限名该用户是不是有，没有就显示没有权限，有就显示子组件。\n\n上面的组件和一般的组件没有什么差别，就是多定义了`getChildContext`方法和`childContextTypes ` 变量。\n\n如何在子组件中拿到permissions呢？\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Menu } from 'antd';\nimport { functionalModules, commonModules } from '../../../permissions/es-header';\n\nexport default class AppHeader extends Component {\n  static contextTypes = {\n    user: PropTypes.object,\n    hasSomePermissions: PropTypes.func\n  }\n\n  getUserName () {\n    let { user } = this.context;\n\n    return (\n      <Menu.SubMenu\n        title={(<span>{user.name}</span>)}\n      >\n      </Menu.SubMenu>\n    );\n  }\n\n  getProducts (modules) {\n    return modules.map((m) => (\n      this.checkAuth(m.apis)\n      ? (\n        <Menu.Item key={m.text}>\n          <a href={m.url}>{m.text}</a>\n        </Menu.Item>\n      )\n      : null\n    )).filter((item) => !!item);\n  }\n\n  checkAuth (apis) {\n    let { hasSomePermissions } = this.context;\n\n    if (apis) {\n      return hasSomePermissions(apis);\n    }\n    return hasSomePermissions(apis);\n  }\n\n  render () {\n    return (\n      <div>\n          <Menu>\n            <Menu.SubMenu title=\"功能1\">\n              <Menu.ItemGroup title=\"具体模块\">\n                {this.getProducts(functionalModules)}\n              </Menu.ItemGroup>\n            </Menu.SubMenu>\n          </Menu>\n          <Menu>\n            {this.getUserName()}\n          </Menu>\n\t\t</div>\n    )\n  }\n}\n\n```\n\n如上代码，只要在组件中定义`contextTypes` ，就能`this.context` 直接调用需要的变量或者方法。\n\n事实上，上面的代码就是路由权限控制的关键。我们把所有完整的路由以json的形式静态保存起来，`Menu.ItemGroup` 组件，渲染出来的就是根据用户的权限从完整路由中过滤出来的目录。\n\n```js\n[\n  {\n    \"apis\": [\n      \"GET_USER_LIST\",\n      \"ADD_USER_ITEM\"\n    ],\n    \"text\": \"用户管理\",\n    \"url\": \"/user\"\n  },\n  {\n    \"apis\": [\n      \"ADD_FEE_ITEM\",\n      \"GET_FEE_LIST\"\n    ],\n    \"text\": \"费用管理\",\n    \"url\": \"/fee\"\n  }\n]\n```\n\n这里实现的是一个很简单顶部。左侧导航栏也是同样的处理思路。\n\n其实上还有一种思路是将路由的组件进行封装，这个组件在挂载前判断是不是有权限，就是利用路由的回调函数`onEnter` ，`onLeave()` 来做。这里没有那样做的理由是，如果按照这种思路来做，那每个路由的回调都会执行一次，有些浪费资源。\n\n具体可以参看其他的文章：https://blog.csdn.net/qq_39985511/article/details/80885158\n\n\n\n### react页面和按钮权限控制\n\n在路由的实现中其实已经实现了`Permission` 组件，无论是页面，还是按钮，只要需要权限控制的地方，就在组件外层添加这个组件，并传入需要的权限名字，如果有权限，就初始化子组件，没有就不处理或者显示没有权限。\n\n一个页面的例子：\n\n```js\nexport default class MyPageContainer extends Component {\n  render () {\n    return (\n      <div>\n        <Breadcrumb routes={routes} params={allParams} />\n        <Permission\n          needPermissions={['GET_LIST']}\n          noPermissionChild={<span>无权限</span>}\n        >\n          <MyPage/>\n        </Permission>\n      </div>\n    )\n  }\n}\n```\n\n一个按钮的例子：\n\n```js\n  render () {\n    return (\n      <div>\n        <Permission\n          needPermissions={['ADD_ITEM']}\n        >\n          <Button>新增</Button>\n        </Permission>\n      </div>\n    );\n  }\n```\n\n\n\n### 发送请求时的权限\n\n这个基于前面的内容，在发送请求的时候再进行一次判断。`Permission` 组件返回了一些方法，可以通过context来获取到。同样这些方法可以判断当前用户是不是拥有该接口的权限。如果拥有就发送请求，否则就不发送。我们可以将发送请求的方法提取出来一并处理。但是我们必须在前端维护一个接口和对应权限名称的文件。这样才能知道哪个接口需要的是什么权限。类似于下面这样。\n\n```js\n{\n  \"URSUSER_GET_LIST\": {\n    \"url\": \"/users/info\",\n    \"method\": \"GET\",\n    \"action\": \"searchUserInfo\",\n    \"resource\": \"/users/info\"\n  },\n  \"URSUSER_MODIFY\": {\n    \"url\": \"/users/modify\",\n    \"method\": \"POST\",\n    \"action\": \"modifyUserInfo\",\n    \"resource\": \"/users/modify\"\n  }\n}\n```\n\n\n\n### 总结\n\n有关权限的控制，都应该由后端来做。前端只是为了提高用户体验，让没有权限的资源不显示出来。前端的控制的主要思路就是有一个公用的方法，这个方法可以判断当前用户是不是拥有需要的权限，然后前端根据这个方法返回的结构生成路由，渲染页面等。\n\n\n\n其他参考文章：\n\nhttps://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/\n","slug":"前端单页系统的权限控制","published":1,"updated":"2018-11-28T07:07:45.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzcif00015oisi7i2qcyr","content":"<h1 id=\"前端单页系统的权限控制\"><a href=\"#前端单页系统的权限控制\" class=\"headerlink\" title=\"前端单页系统的权限控制\"></a>前端单页系统的权限控制</h1><blockquote>\n<p>写在前面：说到权限的控制，前端的权限是不安全的。所有的权限应该都由后端来做才能保证安全。那么我们为什么要在前端做权限控制呢？答案很简单，为了用户体验。一个普通用户明明看到了一个路由，点击以后系统报错说没有权限的体验，远远不如用户一开始并没有看到这个路由。这就是前端做权限控制的意义。也就是说，前端只负责把有权限的页面或者按钮展示给用户，其他的隐藏起来。前端单页的应用大大提升了前端权限控制的需求。很多后台管理系统都是单页应用，也都需要权限控制，这样不同的角色可以进行不同的操作。我所做的项目也是如此。这里将react和react-router等相关的类容一起总结一下。</p>\n</blockquote>\n<h3 id=\"前端的权限的维度\"><a href=\"#前端的权限的维度\" class=\"headerlink\" title=\"前端的权限的维度\"></a>前端的权限的维度</h3><p>经验统计，前端权限的体现主要有以下3种类型：</p>\n<ul>\n<li><p><strong>路由</strong> </p>\n<p>最常见的就是菜单栏或者导航栏的控制，不同的用户看到的菜单栏不一样，比如登录某云的后台管理系统，发现导航栏有2个下拉的选项，而管理员登录却能看到十几二十个下拉选项。这样的权限，通常是针对整个页面的，也就是设计者希望没有权限的人整个页面都看不到。就算使用者知道页面的路由，进去以后依然什么也看不见。</p>\n</li>\n<li><p><strong>按钮</strong> </p>\n<p>同样的页面，可以操作的按钮不一样，比如登录某云的后台管理系统，一个工单，普通用户只看到“查看”按钮，但是管理员就能看到“查看”，“审批”两个按钮。这样的权限，通常是希望使用者能看到页面，但是页面上的某些操作不能操作。</p>\n</li>\n<li><p><strong>请求</strong> </p>\n<p>请求，是前端权限的最后一次拦截。就是即将要发出请求的时候对权限进行检验，如果没有权限则不发送这个请求。</p>\n</li>\n</ul>\n<p>以上3种形式组成了前端权限的控制。</p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>上面说到权限的3中体现，这里说明下针对这3种情况的实现思路</p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>初始化路由之前就拿到权限的列表，再进行初始化，直接根据权限，初始化相应的路由。</p>\n<h4 id=\"页面和按钮\"><a href=\"#页面和按钮\" class=\"headerlink\" title=\"页面和按钮\"></a>页面和按钮</h4><p>后端对于实现权限、日志等功能都是借用AOP面向切面的思想来实现。面向切面的思想把一些与核心业务无关，但任何模块都可能使用的功能抽离出来，然后动态给业务模块添加上需要的功能。然鹅，前端并没有实现动态添加业务模块的机制，不过仍然可以参考这个思想。我们把与权限有关的抽离成一个公用的组件，在需要使用权限的地方初始化这个组件，这个组件的插入尽量做到不影响页面的原有逻辑。</p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><p>可以写一个公用的方法，这个方法可以判断，当前的用户是否有这个接口的访问权限，如果有就发送请求，如果没有就不发送请求。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>上面说了实现的思路，下面就具体说下怎么做。以<code>react</code> + <code>react router</code> 为例。</p>\n<h3 id=\"react路由权限控制\"><a href=\"#react路由权限控制\" class=\"headerlink\" title=\"react路由权限控制\"></a>react路由权限控制</h3><p>想要路由渲染的时候根据权限来进行渲染，那在初始化路由之前就应该拿到权限的列表。因此所有内容都应该在权限加载完以后加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM, &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'es/components/app'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Permission <span class=\"keyword\">from</span> <span class=\"string\">'es/components/permission'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Root <span class=\"keyword\">from</span> <span class=\"string\">'./root'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; needPermissions <span class=\"keyword\">as</span> headPermissions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../../../permissions/es-header'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAPP</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;App&gt;</span><br><span class=\"line\">        &lt;Permission</span><br><span class=\"line\">          queryPermissions=&#123;headPermissions.concat([<span class=\"string\">'ADMINGROUPS_GET_LIST'</span>])&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;Root /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Permission&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>App&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render((&lt;MyAPP /&gt;), document.getElementById('application'))</span><br></pre></td></tr></table></figure>\n<p>上面代码是页面的入口文件。可以看到，这个入口文件最外层组件是<code>App</code> 组件，其次是<code>Permission</code> 组件。 <code>Root</code> 组件就是页面真正的内容。为什么我们需要再最外层套两层呢？因为之前说的，我们在初始化路由的时候需要拿到用户的权限以及用户的信息，于是我们在<code>App</code> 组件获取到用户的信息，在<code>Permission</code> 组件中获取权限。这里可以根据各自的业务逻辑灵活使用，如果不需要用户的信息，可以直接只套一层。</p>\n<p>在上面两个组件中获取到了用户和权限信息，我们怎么传递给其他组价使用呢？react中，传递变量通常是用props一层层往下传，但是像用户信息和权限这类信息，在全局任何地方都有可能用到，如果使用props从顶层组价一层层往下传会显得非常繁琐，debug问题的时候也很难快速定位。有没有什么方法可以让这类信息像全局变量一样，任何一个自组件都能轻松的访问到呢？有一个非官方的方法<code>context</code> 。</p>\n<h5 id=\"Context——定义游离于组件之外的全局变量\"><a href=\"#Context——定义游离于组件之外的全局变量\" class=\"headerlink\" title=\"Context——定义游离于组件之外的全局变量\"></a>Context——定义游离于组件之外的全局变量</h5><p>context的使用非常方便，只要在父组件或者说外层组件定义一个<code>getChildContext</code>方法和<code>childContextTypes</code> 变量，在里层定义<code>contextTypes</code>就可以直接在里层用<code>this.context</code>访问。举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Children, Component, ReactElement &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> request, &#123; getApis &#125; <span class=\"keyword\">from</span> <span class=\"string\">'es/utils/api-request'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> apis <span class=\"keyword\">from</span> <span class=\"string\">'es/constants/apis'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Permission</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  _queryPermissions: <span class=\"built_in\">Array</span>&lt;string&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    permissions: PropTypes.object,</span><br><span class=\"line\">    hasPermissions: PropTypes.func,</span><br><span class=\"line\">    hasSomePermissions: PropTypes.func</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getChildContext () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      permissions: <span class=\"keyword\">this</span>.state.permissions,</span><br><span class=\"line\">      hasPermissions: <span class=\"keyword\">this</span>.hasPermissions.bind(<span class=\"keyword\">this</span>),</span><br><span class=\"line\">      hasSomePermissions: <span class=\"keyword\">this</span>.hasSomePermissions.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    permissions: <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;needPermissions = [], needSomePermissions = [], queryPermissions = []</span><br><span class=\"line\">    &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._queryPermissions = <span class=\"built_in\">Array</span>.from(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...queryPermissions, ...needPermissions, ...needSomePermissions]));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 从后端获取权限并保存在state中*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getPermissions();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* 判断当前用户是否具有传入的权限*/</span></span><br><span class=\"line\">  hasPermissions (checkPermissions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; permissions = &#123;&#125; &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !checkPermissions || checkPermissions.every(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> permissions[p]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* 判断当前用户是否具有传入的权限组*/</span></span><br><span class=\"line\">  hasSomePermissions (checkPermissions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; permissions = &#123;&#125; &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !checkPermissions || checkPermissions.some(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> permissions[p]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; props &#125; = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;needPermissions, needSomePermissions, noPermissionChild &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.permissions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (needPermissions &amp;&amp; !<span class=\"keyword\">this</span>.hasPermissions(needPermissions)) ||</span><br><span class=\"line\">        (needSomePermissions &amp;&amp; !<span class=\"keyword\">this</span>.hasSomePermissions(needSomePermissions))</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        child = noPermissionChild;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        child = props.children;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> child ? Children.only(child) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Permission</code> 组件的主要功能就是，从后端获取所有的permissions，放在自己的state中，并通过context，将permissions以及几个方法存储在全局变量中，判断传入的权限名该用户是不是有，没有就显示没有权限，有就显示子组件。</p>\n<p>上面的组件和一般的组件没有什么差别，就是多定义了<code>getChildContext</code>方法和<code>childContextTypes</code> 变量。</p>\n<p>如何在子组件中拿到permissions呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Menu &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; functionalModules, commonModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../../../permissions/es-header'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppHeader</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">    user: PropTypes.object,</span><br><span class=\"line\">    hasSomePermissions: PropTypes.func</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getUserName () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; user &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Menu.SubMenu</span><br><span class=\"line\">        title=&#123;(&lt;span&gt;&#123;user.name&#125;&lt;/span&gt;)&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Menu.SubMenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  getProducts (modules) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return modules.map((m) =&gt; (</span></span><br><span class=\"line\"><span class=\"regexp\">      this.checkAuth(m.apis)</span></span><br><span class=\"line\"><span class=\"regexp\">      ? (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Menu.Item key=&#123;m.text&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;a href=&#123;m.url&#125;&gt;&#123;m.text&#125;&lt;/</span>a&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Menu.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">      : null</span></span><br><span class=\"line\"><span class=\"regexp\">    )).filter((item) =&gt; !!item);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  checkAuth (apis) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    let &#123; hasSomePermissions &#125; = this.context;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    if (apis) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      return hasSomePermissions(apis);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    return hasSomePermissions(apis);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Menu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;Menu.SubMenu title=\"功能1\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Menu.ItemGroup title=\"具体模块\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;this.getProducts(functionalModules)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;/</span>Menu.ItemGroup&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/Menu.SubMenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>Menu&gt;</span><br><span class=\"line\">          &lt;Menu&gt;</span><br><span class=\"line\">            &#123;<span class=\"keyword\">this</span>.getUserName()&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/Menu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，只要在组件中定义<code>contextTypes</code> ，就能<code>this.context</code> 直接调用需要的变量或者方法。</p>\n<p>事实上，上面的代码就是路由权限控制的关键。我们把所有完整的路由以json的形式静态保存起来，<code>Menu.ItemGroup</code> 组件，渲染出来的就是根据用户的权限从完整路由中过滤出来的目录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"apis\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"GET_USER_LIST\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ADD_USER_ITEM\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"text\"</span>: <span class=\"string\">\"用户管理\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/user\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"apis\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"ADD_FEE_ITEM\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"GET_FEE_LIST\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"text\"</span>: <span class=\"string\">\"费用管理\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/fee\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这里实现的是一个很简单顶部。左侧导航栏也是同样的处理思路。</p>\n<p>其实上还有一种思路是将路由的组件进行封装，这个组件在挂载前判断是不是有权限，就是利用路由的回调函数<code>onEnter</code> ，<code>onLeave()</code> 来做。这里没有那样做的理由是，如果按照这种思路来做，那每个路由的回调都会执行一次，有些浪费资源。</p>\n<p>具体可以参看其他的文章：<a href=\"https://blog.csdn.net/qq_39985511/article/details/80885158\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_39985511/article/details/80885158</a></p>\n<h3 id=\"react页面和按钮权限控制\"><a href=\"#react页面和按钮权限控制\" class=\"headerlink\" title=\"react页面和按钮权限控制\"></a>react页面和按钮权限控制</h3><p>在路由的实现中其实已经实现了<code>Permission</code> 组件，无论是页面，还是按钮，只要需要权限控制的地方，就在组件外层添加这个组件，并传入需要的权限名字，如果有权限，就初始化子组件，没有就不处理或者显示没有权限。</p>\n<p>一个页面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPageContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Breadcrumb routes=&#123;routes&#125; params=&#123;allParams&#125; /&gt;</span><br><span class=\"line\">        &lt;Permission</span><br><span class=\"line\">          needPermissions=&#123;[<span class=\"string\">'GET_LIST'</span>]&#125;</span><br><span class=\"line\">          noPermissionChild=&#123;&lt;span&gt;无权限&lt;<span class=\"regexp\">/span&gt;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;MyPage/</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Permission&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个按钮的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Permission</span><br><span class=\"line\">        needPermissions=&#123;[<span class=\"string\">'ADD_ITEM'</span>]&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Button&gt;新增&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>Permission&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"发送请求时的权限\"><a href=\"#发送请求时的权限\" class=\"headerlink\" title=\"发送请求时的权限\"></a>发送请求时的权限</h3><p>这个基于前面的内容，在发送请求的时候再进行一次判断。<code>Permission</code> 组件返回了一些方法，可以通过context来获取到。同样这些方法可以判断当前用户是不是拥有该接口的权限。如果拥有就发送请求，否则就不发送。我们可以将发送请求的方法提取出来一并处理。但是我们必须在前端维护一个接口和对应权限名称的文件。这样才能知道哪个接口需要的是什么权限。类似于下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"URSUSER_GET_LIST\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/users/info\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"method\"</span>: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"action\"</span>: <span class=\"string\">\"searchUserInfo\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"resource\"</span>: <span class=\"string\">\"/users/info\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"URSUSER_MODIFY\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/users/modify\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"method\"</span>: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"action\"</span>: <span class=\"string\">\"modifyUserInfo\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"resource\"</span>: <span class=\"string\">\"/users/modify\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>有关权限的控制，都应该由后端来做。前端只是为了提高用户体验，让没有权限的资源不显示出来。前端的控制的主要思路就是有一个公用的方法，这个方法可以判断当前用户是不是拥有需要的权限，然后前端根据这个方法返回的结构生成路由，渲染页面等。</p>\n<p>其他参考文章：</p>\n<p><a href=\"https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端单页系统的权限控制\"><a href=\"#前端单页系统的权限控制\" class=\"headerlink\" title=\"前端单页系统的权限控制\"></a>前端单页系统的权限控制</h1><blockquote>\n<p>写在前面：说到权限的控制，前端的权限是不安全的。所有的权限应该都由后端来做才能保证安全。那么我们为什么要在前端做权限控制呢？答案很简单，为了用户体验。一个普通用户明明看到了一个路由，点击以后系统报错说没有权限的体验，远远不如用户一开始并没有看到这个路由。这就是前端做权限控制的意义。也就是说，前端只负责把有权限的页面或者按钮展示给用户，其他的隐藏起来。前端单页的应用大大提升了前端权限控制的需求。很多后台管理系统都是单页应用，也都需要权限控制，这样不同的角色可以进行不同的操作。我所做的项目也是如此。这里将react和react-router等相关的类容一起总结一下。</p>\n</blockquote>\n<h3 id=\"前端的权限的维度\"><a href=\"#前端的权限的维度\" class=\"headerlink\" title=\"前端的权限的维度\"></a>前端的权限的维度</h3><p>经验统计，前端权限的体现主要有以下3种类型：</p>\n<ul>\n<li><p><strong>路由</strong> </p>\n<p>最常见的就是菜单栏或者导航栏的控制，不同的用户看到的菜单栏不一样，比如登录某云的后台管理系统，发现导航栏有2个下拉的选项，而管理员登录却能看到十几二十个下拉选项。这样的权限，通常是针对整个页面的，也就是设计者希望没有权限的人整个页面都看不到。就算使用者知道页面的路由，进去以后依然什么也看不见。</p>\n</li>\n<li><p><strong>按钮</strong> </p>\n<p>同样的页面，可以操作的按钮不一样，比如登录某云的后台管理系统，一个工单，普通用户只看到“查看”按钮，但是管理员就能看到“查看”，“审批”两个按钮。这样的权限，通常是希望使用者能看到页面，但是页面上的某些操作不能操作。</p>\n</li>\n<li><p><strong>请求</strong> </p>\n<p>请求，是前端权限的最后一次拦截。就是即将要发出请求的时候对权限进行检验，如果没有权限则不发送这个请求。</p>\n</li>\n</ul>\n<p>以上3种形式组成了前端权限的控制。</p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>上面说到权限的3中体现，这里说明下针对这3种情况的实现思路</p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>初始化路由之前就拿到权限的列表，再进行初始化，直接根据权限，初始化相应的路由。</p>\n<h4 id=\"页面和按钮\"><a href=\"#页面和按钮\" class=\"headerlink\" title=\"页面和按钮\"></a>页面和按钮</h4><p>后端对于实现权限、日志等功能都是借用AOP面向切面的思想来实现。面向切面的思想把一些与核心业务无关，但任何模块都可能使用的功能抽离出来，然后动态给业务模块添加上需要的功能。然鹅，前端并没有实现动态添加业务模块的机制，不过仍然可以参考这个思想。我们把与权限有关的抽离成一个公用的组件，在需要使用权限的地方初始化这个组件，这个组件的插入尽量做到不影响页面的原有逻辑。</p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><p>可以写一个公用的方法，这个方法可以判断，当前的用户是否有这个接口的访问权限，如果有就发送请求，如果没有就不发送请求。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>上面说了实现的思路，下面就具体说下怎么做。以<code>react</code> + <code>react router</code> 为例。</p>\n<h3 id=\"react路由权限控制\"><a href=\"#react路由权限控制\" class=\"headerlink\" title=\"react路由权限控制\"></a>react路由权限控制</h3><p>想要路由渲染的时候根据权限来进行渲染，那在初始化路由之前就应该拿到权限的列表。因此所有内容都应该在权限加载完以后加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM, &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'es/components/app'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Permission <span class=\"keyword\">from</span> <span class=\"string\">'es/components/permission'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Root <span class=\"keyword\">from</span> <span class=\"string\">'./root'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; needPermissions <span class=\"keyword\">as</span> headPermissions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../../../permissions/es-header'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAPP</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;App&gt;</span><br><span class=\"line\">        &lt;Permission</span><br><span class=\"line\">          queryPermissions=&#123;headPermissions.concat([<span class=\"string\">'ADMINGROUPS_GET_LIST'</span>])&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">          &lt;Root /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Permission&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>App&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render((&lt;MyAPP /&gt;), document.getElementById('application'))</span><br></pre></td></tr></table></figure>\n<p>上面代码是页面的入口文件。可以看到，这个入口文件最外层组件是<code>App</code> 组件，其次是<code>Permission</code> 组件。 <code>Root</code> 组件就是页面真正的内容。为什么我们需要再最外层套两层呢？因为之前说的，我们在初始化路由的时候需要拿到用户的权限以及用户的信息，于是我们在<code>App</code> 组件获取到用户的信息，在<code>Permission</code> 组件中获取权限。这里可以根据各自的业务逻辑灵活使用，如果不需要用户的信息，可以直接只套一层。</p>\n<p>在上面两个组件中获取到了用户和权限信息，我们怎么传递给其他组价使用呢？react中，传递变量通常是用props一层层往下传，但是像用户信息和权限这类信息，在全局任何地方都有可能用到，如果使用props从顶层组价一层层往下传会显得非常繁琐，debug问题的时候也很难快速定位。有没有什么方法可以让这类信息像全局变量一样，任何一个自组件都能轻松的访问到呢？有一个非官方的方法<code>context</code> 。</p>\n<h5 id=\"Context——定义游离于组件之外的全局变量\"><a href=\"#Context——定义游离于组件之外的全局变量\" class=\"headerlink\" title=\"Context——定义游离于组件之外的全局变量\"></a>Context——定义游离于组件之外的全局变量</h5><p>context的使用非常方便，只要在父组件或者说外层组件定义一个<code>getChildContext</code>方法和<code>childContextTypes</code> 变量，在里层定义<code>contextTypes</code>就可以直接在里层用<code>this.context</code>访问。举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Children, Component, ReactElement &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> request, &#123; getApis &#125; <span class=\"keyword\">from</span> <span class=\"string\">'es/utils/api-request'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> apis <span class=\"keyword\">from</span> <span class=\"string\">'es/constants/apis'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Permission</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  _queryPermissions: <span class=\"built_in\">Array</span>&lt;string&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> childContextTypes = &#123;</span><br><span class=\"line\">    permissions: PropTypes.object,</span><br><span class=\"line\">    hasPermissions: PropTypes.func,</span><br><span class=\"line\">    hasSomePermissions: PropTypes.func</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getChildContext () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      permissions: <span class=\"keyword\">this</span>.state.permissions,</span><br><span class=\"line\">      hasPermissions: <span class=\"keyword\">this</span>.hasPermissions.bind(<span class=\"keyword\">this</span>),</span><br><span class=\"line\">      hasSomePermissions: <span class=\"keyword\">this</span>.hasSomePermissions.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    permissions: <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;needPermissions = [], needSomePermissions = [], queryPermissions = []</span><br><span class=\"line\">    &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._queryPermissions = <span class=\"built_in\">Array</span>.from(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...queryPermissions, ...needPermissions, ...needSomePermissions]));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 从后端获取权限并保存在state中*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getPermissions();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* 判断当前用户是否具有传入的权限*/</span></span><br><span class=\"line\">  hasPermissions (checkPermissions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; permissions = &#123;&#125; &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !checkPermissions || checkPermissions.every(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> permissions[p]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t<span class=\"comment\">/* 判断当前用户是否具有传入的权限组*/</span></span><br><span class=\"line\">  hasSomePermissions (checkPermissions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; permissions = &#123;&#125; &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !checkPermissions || checkPermissions.some(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> permissions[p]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; props &#125; = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;needPermissions, needSomePermissions, noPermissionChild &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.permissions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (needPermissions &amp;&amp; !<span class=\"keyword\">this</span>.hasPermissions(needPermissions)) ||</span><br><span class=\"line\">        (needSomePermissions &amp;&amp; !<span class=\"keyword\">this</span>.hasSomePermissions(needSomePermissions))</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        child = noPermissionChild;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        child = props.children;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> child ? Children.only(child) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Permission</code> 组件的主要功能就是，从后端获取所有的permissions，放在自己的state中，并通过context，将permissions以及几个方法存储在全局变量中，判断传入的权限名该用户是不是有，没有就显示没有权限，有就显示子组件。</p>\n<p>上面的组件和一般的组件没有什么差别，就是多定义了<code>getChildContext</code>方法和<code>childContextTypes</code> 变量。</p>\n<p>如何在子组件中拿到permissions呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Menu &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; functionalModules, commonModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../../../permissions/es-header'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppHeader</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextTypes = &#123;</span><br><span class=\"line\">    user: PropTypes.object,</span><br><span class=\"line\">    hasSomePermissions: PropTypes.func</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getUserName () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; user &#125; = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Menu.SubMenu</span><br><span class=\"line\">        title=&#123;(&lt;span&gt;&#123;user.name&#125;&lt;/span&gt;)&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Menu.SubMenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  getProducts (modules) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return modules.map((m) =&gt; (</span></span><br><span class=\"line\"><span class=\"regexp\">      this.checkAuth(m.apis)</span></span><br><span class=\"line\"><span class=\"regexp\">      ? (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Menu.Item key=&#123;m.text&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;a href=&#123;m.url&#125;&gt;&#123;m.text&#125;&lt;/</span>a&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Menu.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">      : null</span></span><br><span class=\"line\"><span class=\"regexp\">    )).filter((item) =&gt; !!item);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  checkAuth (apis) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    let &#123; hasSomePermissions &#125; = this.context;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    if (apis) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      return hasSomePermissions(apis);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    return hasSomePermissions(apis);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Menu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;Menu.SubMenu title=\"功能1\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;Menu.ItemGroup title=\"具体模块\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;this.getProducts(functionalModules)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">              &lt;/</span>Menu.ItemGroup&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/Menu.SubMenu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>Menu&gt;</span><br><span class=\"line\">          &lt;Menu&gt;</span><br><span class=\"line\">            &#123;<span class=\"keyword\">this</span>.getUserName()&#125;</span><br><span class=\"line\">          &lt;<span class=\"regexp\">/Menu&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t&lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，只要在组件中定义<code>contextTypes</code> ，就能<code>this.context</code> 直接调用需要的变量或者方法。</p>\n<p>事实上，上面的代码就是路由权限控制的关键。我们把所有完整的路由以json的形式静态保存起来，<code>Menu.ItemGroup</code> 组件，渲染出来的就是根据用户的权限从完整路由中过滤出来的目录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"apis\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"GET_USER_LIST\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ADD_USER_ITEM\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"text\"</span>: <span class=\"string\">\"用户管理\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/user\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"apis\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"ADD_FEE_ITEM\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"GET_FEE_LIST\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"text\"</span>: <span class=\"string\">\"费用管理\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/fee\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这里实现的是一个很简单顶部。左侧导航栏也是同样的处理思路。</p>\n<p>其实上还有一种思路是将路由的组件进行封装，这个组件在挂载前判断是不是有权限，就是利用路由的回调函数<code>onEnter</code> ，<code>onLeave()</code> 来做。这里没有那样做的理由是，如果按照这种思路来做，那每个路由的回调都会执行一次，有些浪费资源。</p>\n<p>具体可以参看其他的文章：<a href=\"https://blog.csdn.net/qq_39985511/article/details/80885158\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_39985511/article/details/80885158</a></p>\n<h3 id=\"react页面和按钮权限控制\"><a href=\"#react页面和按钮权限控制\" class=\"headerlink\" title=\"react页面和按钮权限控制\"></a>react页面和按钮权限控制</h3><p>在路由的实现中其实已经实现了<code>Permission</code> 组件，无论是页面，还是按钮，只要需要权限控制的地方，就在组件外层添加这个组件，并传入需要的权限名字，如果有权限，就初始化子组件，没有就不处理或者显示没有权限。</p>\n<p>一个页面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPageContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Breadcrumb routes=&#123;routes&#125; params=&#123;allParams&#125; /&gt;</span><br><span class=\"line\">        &lt;Permission</span><br><span class=\"line\">          needPermissions=&#123;[<span class=\"string\">'GET_LIST'</span>]&#125;</span><br><span class=\"line\">          noPermissionChild=&#123;&lt;span&gt;无权限&lt;<span class=\"regexp\">/span&gt;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;MyPage/</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Permission&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个按钮的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Permission</span><br><span class=\"line\">        needPermissions=&#123;[<span class=\"string\">'ADD_ITEM'</span>]&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;Button&gt;新增&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>Permission&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"发送请求时的权限\"><a href=\"#发送请求时的权限\" class=\"headerlink\" title=\"发送请求时的权限\"></a>发送请求时的权限</h3><p>这个基于前面的内容，在发送请求的时候再进行一次判断。<code>Permission</code> 组件返回了一些方法，可以通过context来获取到。同样这些方法可以判断当前用户是不是拥有该接口的权限。如果拥有就发送请求，否则就不发送。我们可以将发送请求的方法提取出来一并处理。但是我们必须在前端维护一个接口和对应权限名称的文件。这样才能知道哪个接口需要的是什么权限。类似于下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"URSUSER_GET_LIST\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/users/info\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"method\"</span>: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"action\"</span>: <span class=\"string\">\"searchUserInfo\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"resource\"</span>: <span class=\"string\">\"/users/info\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"URSUSER_MODIFY\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"/users/modify\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"method\"</span>: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"action\"</span>: <span class=\"string\">\"modifyUserInfo\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"resource\"</span>: <span class=\"string\">\"/users/modify\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>有关权限的控制，都应该由后端来做。前端只是为了提高用户体验，让没有权限的资源不显示出来。前端的控制的主要思路就是有一个公用的方法，这个方法可以判断当前用户是不是拥有需要的权限，然后前端根据这个方法返回的结构生成路由，渲染页面等。</p>\n<p>其他参考文章：</p>\n<p><a href=\"https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</a></p>\n"},{"title":"'function-组件-sdk'","date":"2018-06-08T01:34:58.000Z","_content":"# function -> 组件 -> sdk\n\n> 写在前面：在开发的过中很多时候都会用到组件，有的人在初期搭建了项目，有的后来就可以直接使用项目中已有的组件。但是当需求中有一个需求是项目中没有的组件，这个组件又可能是以后常用的组件，那我们只能自己动手写组件了。\n\n\n\n## 组件是什么\n\n我的理解是，项目中反复会用到，具有固定功能的模块。比如：弹框，日历，autocomplete，当然还有所有的表单元素。\n\n为了说的简单，就拿一个相对独立的组件弹窗来举例。如果自己需要实现一个弹窗，我们应该如同动手？\n\n回到我说的定义，组件是具有固定功能的模块，意思就是说只要我适当的使用它，它总能实现固定的功能。\n\n## 组件要素\n\n那我可以抽象的认为，组件就像一个function，一个function通常的要素是什么：名字，入参，返回值。\n\n```js\nvar myFunction = function (a, b) {return a * b}\n```\n\n组件其实和这个很相似，举个例子，弹框组件通常是下面这个的样子。\n\n![弹窗组件](function-组件-sdk/component1.png)\n\n### 入参\n\n* content\n\n  从图上我们很容易看出，几乎只有中间部分的内容是需要调用者自己输入的内容。其他的我们希望只要初始化这个组件，就有一个一模一样的弹窗出现。\n\n  如果我们把组件当成一个function的话，那我们找到了弹窗组件需要用户输入的第一个内容：中间的内容，我们用一个变量content来表示。\n\n\n* title\n\n  还有什么事需要输入的呢？没错title，我们其实不希望new一个弹窗以后出现的title是“title”，几个字，而是我们自己定义的名字，这样我们就找了第二个需要输入的变量：title。\n\n\n* 点击ok按钮的回调函数\n\n  通常使用者点击了弹框上面的ok按钮，代表用户同意做某个事情，那些可以执行接下来的操作，那些操作其实和弹框组件本身无关，但是点击ok按钮又必要要触发这个逻辑，那我们选择以回调函数的方式传进组件来。\n\n* 组件宽度\n\n### 组件本身的功能\n\n本身的功能是指那些不需要依赖外部参数就能完成的功能。\n\n* 关闭\n\n  这个弹窗的右上的关闭按钮和cancel按钮点击以后通常会关闭弹窗，这个功能通常可以在组件本身完成。因为关闭弹窗不需要处理任何问题\n\n* 初始化\n\n  初始化这个组件一定会发生，因为既然是一个组件，想要使用就会初始化。\n\n### 返回值\n\n组件返回其实就是就是一个弹框。\n\n\n\n## 组件开发\n\n有了上面的开发，我们大致能想象出如下框架\n\n```javascript\nvar Modal = Regular.extend({\n    name: 'modal',\n    template: tpl,\n    config: function() {\n      _.$extend(this.data, {\n          title: 'title', //默认属性值\n          width：400,\n          content: '',\n          okButton: true,\n          cancelButton: false,\n          visible:true\n      });\n      this.supr();\n    },\n\n    init: function() {\n      this.supr();\n      this.$inject(document.body);\n    },\n\n    ok: function() {\n      this.$emit('ok');\n      this.destroy();\n    },\n\n    cancel: function() {\n      this.$emit('cancel');\n      this.destroy();\n    }\n  });\n```\n\n可以说所有的入参都是组件的可配置功能，入参有的必须传入的，有的是非必传的。大部分的情况我们会给某些参数写一个默认值，如果开发者在初始化的时候灭有传这个参数，就使用默认值。但也有一些必传参数无法给与默认值，必须由开发者传入。\n\n可以说这就是组件的基本架构，有传入的参数，有组件自己的变量和方法，有回调函数。\n\n## 其他组件开发\n\n同理，我们可以分析出一个autocomplate组件架构\n\n![autocomplate组件](function-组件-sdk/component2.png)\n\n这个组件大家一定不陌生，就是复杂一点的输入框。基本功能是，当用户输入的时，能根据输入的字符匹配到联想内类展示在下面，如果用户点击或者用键盘选择某个值则联想框消失，或者输入的字符没有匹配到联想的任何内容，联想框也不会出现。最后，如果用户点击了联想框以外的地方，联想框也消失。\n\nhttps://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js\n\n* 入参：\n\n  * 联想的数据源items（可以是静态的，也可以是请求得到的数据）\n  * 当用户选择了某个值最后的结果返回给回调函数getVal\n\n* 功能：\n\n  * 获取input输入的值getInputValue\n  * 监听input的变化onChange\n  * 监听键盘选择onSelect\n  * input失焦，则收起联想，并返回最终值onInputBlur\n\n* 返回值：\n\n  * 最终用户选择的联想值，如果没有选择的联想值则返回input框输入的值\n\n所以根据上面的分析，我们组件大致是下面这个样子：\n\n```js\nvar Autocomplate = Regular.extend({\n    name: 'autocomplate',\n    template: tpl,\n    config: function() {\n      _.$extend(this.data, {\n          items: {}, //默认属性值\n          isOpen: false，\n          realValue：''\n      });\n      this.supr();\n    },\n\n    init: function() {\n      this.supr();\n    },\n\n    onChange: function() {\n      this.data.isOpen = true;\n      this.getRealValue();\n      this.$emit('getVal',this.data.realValue);\n    },\n\n    onSelect: function() {\n      this.data.isOpen = false;\n      this.getRealValue();\n      this.$emit('getVal',this.data.realValue);\n    },\n\n   onInputBlur: function() {\n     this.data.isOpen = false;\n     this.getRealValue();\n     this.$emit('getVal', this.data.realValue);\n    },\n\n   getInputValue: function() {\n      return this.data.input;\n    },\n\n    getRealValue: function() {\n\n    }\n  });\n```\n\n这里只是写个大概，最终当然还有很多需要处理的内容。但是大体的结构也就是那三个最重要的要素。入参，功能，返回值。也就是，传入的静态变量和回调函数，组件本身的功能函数，和返回值。\n\n事实上我们很多常用的组件，都是用这样的思路写出来的，像slider，page等，但是根据功能的不同复杂程度也不同。\n\n\n\n## SDK的开发\n\nSDK是什么？我的理解就是具有一定功能的集合，这听起来是不是和组件很相似。没错，我觉得非常相似。\n\n下面举个栗子：\n\n```js\nnew SDK({\n        container: elementID,\n        onSuccess: function (result) {\n          if (result.ret) {\n  \t\t\t//一些处理\n          }\n        },\n        onFail: function () {\n          //一些处理\n        }\n      });\n```\n\n这个SDK的组件有3个入参，分别是1个静态变量和两个回调函数，从onSuccess回调函数可能看出，这个这组件的返回值是result。这就是最常见的SDK初始化过程。\n\n### SDK功能\n\n需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。\n\n说白了就是，他们new一下就出现一个我们提供的登录框，如下图：\n\n![登录组件](function-组件-sdk\\postMessage.png)\n\n初步分析\n\n* 入参:\n  * 需要指定的div的id\n  * 需要成功和失败的回调函数\n* 功能：\n  * 我方负责渲染页面插入指定的id的div\n  * 我方服务器返回的信息要通知业务方，涉及到跨域\n  * 成功以后执行回调函数\n  * 销毁SDK\n* 返回值：\n  * ret\n\n综上，我们的SDK大概的样子就是这样：\n\n```js\ndefine([], function(){\n\n  var SDK = function(options){\n    options = options || {};\n    this.container = options.container;\n    this.createBody(options);\n    this.onMessage(options.onSuccess, options.onFail);\n  },\n\n  pro = SDK.prototype;\n\n  pro.createBody = function(options){\n    this.body = this.container;\n    this.addIframe('https://fdfdfdfd');\n  }\n\n  pro.addIframe = function(url){\n    this.nIframe = document.createElement('iframe');\n    this.nIframe.src = url;\n    this.body.appendChild(this.nIframe);\n  }\n\n  pro.onMessage = function(onSuccess, onFail){\n    window.onmessage = util._$bind(function(event){\n      event = event || window.event;\n      var data = JSON.parse(event.data),\n          ret = data.ret;\n      if(ret){\n        if(typeof onSuccess=== 'function')){\n          onSuccess.call(this, data);\n        }\n      }else{\n        if(typeof onFail=== 'function'){\n          onFail.call(this);\n        }\n      }\n    }, this);\n  }\n\n  pro.close = function(){\n    document.body.removeChild(this.__body);\n  }\n\n  window.NEO = NEO;\n  return NEO;\n\n})\n```\n\n以上就是我想要分享的组件和SDK开发思路。","source":"_posts/function-组件-sdk.md","raw":"---\ntitle: '''function-组件-sdk'''\ndate: 2018-06-08 09:34:58\ntags:\n- 前端\n- js\n- 组件\n---\n# function -> 组件 -> sdk\n\n> 写在前面：在开发的过中很多时候都会用到组件，有的人在初期搭建了项目，有的后来就可以直接使用项目中已有的组件。但是当需求中有一个需求是项目中没有的组件，这个组件又可能是以后常用的组件，那我们只能自己动手写组件了。\n\n\n\n## 组件是什么\n\n我的理解是，项目中反复会用到，具有固定功能的模块。比如：弹框，日历，autocomplete，当然还有所有的表单元素。\n\n为了说的简单，就拿一个相对独立的组件弹窗来举例。如果自己需要实现一个弹窗，我们应该如同动手？\n\n回到我说的定义，组件是具有固定功能的模块，意思就是说只要我适当的使用它，它总能实现固定的功能。\n\n## 组件要素\n\n那我可以抽象的认为，组件就像一个function，一个function通常的要素是什么：名字，入参，返回值。\n\n```js\nvar myFunction = function (a, b) {return a * b}\n```\n\n组件其实和这个很相似，举个例子，弹框组件通常是下面这个的样子。\n\n![弹窗组件](function-组件-sdk/component1.png)\n\n### 入参\n\n* content\n\n  从图上我们很容易看出，几乎只有中间部分的内容是需要调用者自己输入的内容。其他的我们希望只要初始化这个组件，就有一个一模一样的弹窗出现。\n\n  如果我们把组件当成一个function的话，那我们找到了弹窗组件需要用户输入的第一个内容：中间的内容，我们用一个变量content来表示。\n\n\n* title\n\n  还有什么事需要输入的呢？没错title，我们其实不希望new一个弹窗以后出现的title是“title”，几个字，而是我们自己定义的名字，这样我们就找了第二个需要输入的变量：title。\n\n\n* 点击ok按钮的回调函数\n\n  通常使用者点击了弹框上面的ok按钮，代表用户同意做某个事情，那些可以执行接下来的操作，那些操作其实和弹框组件本身无关，但是点击ok按钮又必要要触发这个逻辑，那我们选择以回调函数的方式传进组件来。\n\n* 组件宽度\n\n### 组件本身的功能\n\n本身的功能是指那些不需要依赖外部参数就能完成的功能。\n\n* 关闭\n\n  这个弹窗的右上的关闭按钮和cancel按钮点击以后通常会关闭弹窗，这个功能通常可以在组件本身完成。因为关闭弹窗不需要处理任何问题\n\n* 初始化\n\n  初始化这个组件一定会发生，因为既然是一个组件，想要使用就会初始化。\n\n### 返回值\n\n组件返回其实就是就是一个弹框。\n\n\n\n## 组件开发\n\n有了上面的开发，我们大致能想象出如下框架\n\n```javascript\nvar Modal = Regular.extend({\n    name: 'modal',\n    template: tpl,\n    config: function() {\n      _.$extend(this.data, {\n          title: 'title', //默认属性值\n          width：400,\n          content: '',\n          okButton: true,\n          cancelButton: false,\n          visible:true\n      });\n      this.supr();\n    },\n\n    init: function() {\n      this.supr();\n      this.$inject(document.body);\n    },\n\n    ok: function() {\n      this.$emit('ok');\n      this.destroy();\n    },\n\n    cancel: function() {\n      this.$emit('cancel');\n      this.destroy();\n    }\n  });\n```\n\n可以说所有的入参都是组件的可配置功能，入参有的必须传入的，有的是非必传的。大部分的情况我们会给某些参数写一个默认值，如果开发者在初始化的时候灭有传这个参数，就使用默认值。但也有一些必传参数无法给与默认值，必须由开发者传入。\n\n可以说这就是组件的基本架构，有传入的参数，有组件自己的变量和方法，有回调函数。\n\n## 其他组件开发\n\n同理，我们可以分析出一个autocomplate组件架构\n\n![autocomplate组件](function-组件-sdk/component2.png)\n\n这个组件大家一定不陌生，就是复杂一点的输入框。基本功能是，当用户输入的时，能根据输入的字符匹配到联想内类展示在下面，如果用户点击或者用键盘选择某个值则联想框消失，或者输入的字符没有匹配到联想的任何内容，联想框也不会出现。最后，如果用户点击了联想框以外的地方，联想框也消失。\n\nhttps://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js\n\n* 入参：\n\n  * 联想的数据源items（可以是静态的，也可以是请求得到的数据）\n  * 当用户选择了某个值最后的结果返回给回调函数getVal\n\n* 功能：\n\n  * 获取input输入的值getInputValue\n  * 监听input的变化onChange\n  * 监听键盘选择onSelect\n  * input失焦，则收起联想，并返回最终值onInputBlur\n\n* 返回值：\n\n  * 最终用户选择的联想值，如果没有选择的联想值则返回input框输入的值\n\n所以根据上面的分析，我们组件大致是下面这个样子：\n\n```js\nvar Autocomplate = Regular.extend({\n    name: 'autocomplate',\n    template: tpl,\n    config: function() {\n      _.$extend(this.data, {\n          items: {}, //默认属性值\n          isOpen: false，\n          realValue：''\n      });\n      this.supr();\n    },\n\n    init: function() {\n      this.supr();\n    },\n\n    onChange: function() {\n      this.data.isOpen = true;\n      this.getRealValue();\n      this.$emit('getVal',this.data.realValue);\n    },\n\n    onSelect: function() {\n      this.data.isOpen = false;\n      this.getRealValue();\n      this.$emit('getVal',this.data.realValue);\n    },\n\n   onInputBlur: function() {\n     this.data.isOpen = false;\n     this.getRealValue();\n     this.$emit('getVal', this.data.realValue);\n    },\n\n   getInputValue: function() {\n      return this.data.input;\n    },\n\n    getRealValue: function() {\n\n    }\n  });\n```\n\n这里只是写个大概，最终当然还有很多需要处理的内容。但是大体的结构也就是那三个最重要的要素。入参，功能，返回值。也就是，传入的静态变量和回调函数，组件本身的功能函数，和返回值。\n\n事实上我们很多常用的组件，都是用这样的思路写出来的，像slider，page等，但是根据功能的不同复杂程度也不同。\n\n\n\n## SDK的开发\n\nSDK是什么？我的理解就是具有一定功能的集合，这听起来是不是和组件很相似。没错，我觉得非常相似。\n\n下面举个栗子：\n\n```js\nnew SDK({\n        container: elementID,\n        onSuccess: function (result) {\n          if (result.ret) {\n  \t\t\t//一些处理\n          }\n        },\n        onFail: function () {\n          //一些处理\n        }\n      });\n```\n\n这个SDK的组件有3个入参，分别是1个静态变量和两个回调函数，从onSuccess回调函数可能看出，这个这组件的返回值是result。这就是最常见的SDK初始化过程。\n\n### SDK功能\n\n需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。\n\n说白了就是，他们new一下就出现一个我们提供的登录框，如下图：\n\n![登录组件](function-组件-sdk\\postMessage.png)\n\n初步分析\n\n* 入参:\n  * 需要指定的div的id\n  * 需要成功和失败的回调函数\n* 功能：\n  * 我方负责渲染页面插入指定的id的div\n  * 我方服务器返回的信息要通知业务方，涉及到跨域\n  * 成功以后执行回调函数\n  * 销毁SDK\n* 返回值：\n  * ret\n\n综上，我们的SDK大概的样子就是这样：\n\n```js\ndefine([], function(){\n\n  var SDK = function(options){\n    options = options || {};\n    this.container = options.container;\n    this.createBody(options);\n    this.onMessage(options.onSuccess, options.onFail);\n  },\n\n  pro = SDK.prototype;\n\n  pro.createBody = function(options){\n    this.body = this.container;\n    this.addIframe('https://fdfdfdfd');\n  }\n\n  pro.addIframe = function(url){\n    this.nIframe = document.createElement('iframe');\n    this.nIframe.src = url;\n    this.body.appendChild(this.nIframe);\n  }\n\n  pro.onMessage = function(onSuccess, onFail){\n    window.onmessage = util._$bind(function(event){\n      event = event || window.event;\n      var data = JSON.parse(event.data),\n          ret = data.ret;\n      if(ret){\n        if(typeof onSuccess=== 'function')){\n          onSuccess.call(this, data);\n        }\n      }else{\n        if(typeof onFail=== 'function'){\n          onFail.call(this);\n        }\n      }\n    }, this);\n  }\n\n  pro.close = function(){\n    document.body.removeChild(this.__body);\n  }\n\n  window.NEO = NEO;\n  return NEO;\n\n})\n```\n\n以上就是我想要分享的组件和SDK开发思路。","slug":"function-组件-sdk","published":1,"updated":"2018-06-08T02:07:12.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzcij00035oisfg456ov8","content":"<h1 id=\"function-gt-组件-gt-sdk\"><a href=\"#function-gt-组件-gt-sdk\" class=\"headerlink\" title=\"function -&gt; 组件 -&gt; sdk\"></a>function -&gt; 组件 -&gt; sdk</h1><blockquote>\n<p>写在前面：在开发的过中很多时候都会用到组件，有的人在初期搭建了项目，有的后来就可以直接使用项目中已有的组件。但是当需求中有一个需求是项目中没有的组件，这个组件又可能是以后常用的组件，那我们只能自己动手写组件了。</p>\n</blockquote>\n<h2 id=\"组件是什么\"><a href=\"#组件是什么\" class=\"headerlink\" title=\"组件是什么\"></a>组件是什么</h2><p>我的理解是，项目中反复会用到，具有固定功能的模块。比如：弹框，日历，autocomplete，当然还有所有的表单元素。</p>\n<p>为了说的简单，就拿一个相对独立的组件弹窗来举例。如果自己需要实现一个弹窗，我们应该如同动手？</p>\n<p>回到我说的定义，组件是具有固定功能的模块，意思就是说只要我适当的使用它，它总能实现固定的功能。</p>\n<h2 id=\"组件要素\"><a href=\"#组件要素\" class=\"headerlink\" title=\"组件要素\"></a>组件要素</h2><p>那我可以抽象的认为，组件就像一个function，一个function通常的要素是什么：名字，入参，返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a * b&#125;</span><br></pre></td></tr></table></figure>\n<p>组件其实和这个很相似，举个例子，弹框组件通常是下面这个的样子。</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/component1.png\" alt=\"弹窗组件\"></p>\n<h3 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h3><ul>\n<li><p>content</p>\n<p>从图上我们很容易看出，几乎只有中间部分的内容是需要调用者自己输入的内容。其他的我们希望只要初始化这个组件，就有一个一模一样的弹窗出现。</p>\n<p>如果我们把组件当成一个function的话，那我们找到了弹窗组件需要用户输入的第一个内容：中间的内容，我们用一个变量content来表示。</p>\n</li>\n</ul>\n<ul>\n<li><p>title</p>\n<p>还有什么事需要输入的呢？没错title，我们其实不希望new一个弹窗以后出现的title是“title”，几个字，而是我们自己定义的名字，这样我们就找了第二个需要输入的变量：title。</p>\n</li>\n</ul>\n<ul>\n<li><p>点击ok按钮的回调函数</p>\n<p>通常使用者点击了弹框上面的ok按钮，代表用户同意做某个事情，那些可以执行接下来的操作，那些操作其实和弹框组件本身无关，但是点击ok按钮又必要要触发这个逻辑，那我们选择以回调函数的方式传进组件来。</p>\n</li>\n<li><p>组件宽度</p>\n</li>\n</ul>\n<h3 id=\"组件本身的功能\"><a href=\"#组件本身的功能\" class=\"headerlink\" title=\"组件本身的功能\"></a>组件本身的功能</h3><p>本身的功能是指那些不需要依赖外部参数就能完成的功能。</p>\n<ul>\n<li><p>关闭</p>\n<p>这个弹窗的右上的关闭按钮和cancel按钮点击以后通常会关闭弹窗，这个功能通常可以在组件本身完成。因为关闭弹窗不需要处理任何问题</p>\n</li>\n<li><p>初始化</p>\n<p>初始化这个组件一定会发生，因为既然是一个组件，想要使用就会初始化。</p>\n</li>\n</ul>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>组件返回其实就是就是一个弹框。</p>\n<h2 id=\"组件开发\"><a href=\"#组件开发\" class=\"headerlink\" title=\"组件开发\"></a>组件开发</h2><p>有了上面的开发，我们大致能想象出如下框架</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Modal = Regular.extend(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'modal'</span>,</span><br><span class=\"line\">    template: tpl,</span><br><span class=\"line\">    config: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      _.$extend(<span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">          title: <span class=\"string\">'title'</span>, <span class=\"comment\">//默认属性值</span></span><br><span class=\"line\">          width：<span class=\"number\">400</span>,</span><br><span class=\"line\">          content: <span class=\"string\">''</span>,</span><br><span class=\"line\">          okButton: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          cancelButton: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          visible:<span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$inject(<span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    ok: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'ok'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.destroy();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    cancel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'cancel'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>可以说所有的入参都是组件的可配置功能，入参有的必须传入的，有的是非必传的。大部分的情况我们会给某些参数写一个默认值，如果开发者在初始化的时候灭有传这个参数，就使用默认值。但也有一些必传参数无法给与默认值，必须由开发者传入。</p>\n<p>可以说这就是组件的基本架构，有传入的参数，有组件自己的变量和方法，有回调函数。</p>\n<h2 id=\"其他组件开发\"><a href=\"#其他组件开发\" class=\"headerlink\" title=\"其他组件开发\"></a>其他组件开发</h2><p>同理，我们可以分析出一个autocomplate组件架构</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/component2.png\" alt=\"autocomplate组件\"></p>\n<p>这个组件大家一定不陌生，就是复杂一点的输入框。基本功能是，当用户输入的时，能根据输入的字符匹配到联想内类展示在下面，如果用户点击或者用键盘选择某个值则联想框消失，或者输入的字符没有匹配到联想的任何内容，联想框也不会出现。最后，如果用户点击了联想框以外的地方，联想框也消失。</p>\n<p><a href=\"https://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js\" target=\"_blank\" rel=\"noopener\">https://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js</a></p>\n<ul>\n<li><p>入参：</p>\n<ul>\n<li>联想的数据源items（可以是静态的，也可以是请求得到的数据）</li>\n<li>当用户选择了某个值最后的结果返回给回调函数getVal</li>\n</ul>\n</li>\n<li><p>功能：</p>\n<ul>\n<li>获取input输入的值getInputValue</li>\n<li>监听input的变化onChange</li>\n<li>监听键盘选择onSelect</li>\n<li>input失焦，则收起联想，并返回最终值onInputBlur</li>\n</ul>\n</li>\n<li><p>返回值：</p>\n<ul>\n<li>最终用户选择的联想值，如果没有选择的联想值则返回input框输入的值</li>\n</ul>\n</li>\n</ul>\n<p>所以根据上面的分析，我们组件大致是下面这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Autocomplate = Regular.extend(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'autocomplate'</span>,</span><br><span class=\"line\">    template: tpl,</span><br><span class=\"line\">    config: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      _.$extend(<span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">          items: &#123;&#125;, <span class=\"comment\">//默认属性值</span></span><br><span class=\"line\">          isOpen: <span class=\"literal\">false</span>，</span><br><span class=\"line\">          realValue：<span class=\"string\">''</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    onChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>,<span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    onSelect: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>,<span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   onInputBlur: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>, <span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   getInputValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.input;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    getRealValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里只是写个大概，最终当然还有很多需要处理的内容。但是大体的结构也就是那三个最重要的要素。入参，功能，返回值。也就是，传入的静态变量和回调函数，组件本身的功能函数，和返回值。</p>\n<p>事实上我们很多常用的组件，都是用这样的思路写出来的，像slider，page等，但是根据功能的不同复杂程度也不同。</p>\n<h2 id=\"SDK的开发\"><a href=\"#SDK的开发\" class=\"headerlink\" title=\"SDK的开发\"></a>SDK的开发</h2><p>SDK是什么？我的理解就是具有一定功能的集合，这听起来是不是和组件很相似。没错，我觉得非常相似。</p>\n<p>下面举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> SDK(&#123;</span><br><span class=\"line\">        container: elementID,</span><br><span class=\"line\">        onSuccess: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (result.ret) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//一些处理</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        onFail: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//一些处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br></pre></td></tr></table></figure>\n<p>这个SDK的组件有3个入参，分别是1个静态变量和两个回调函数，从onSuccess回调函数可能看出，这个这组件的返回值是result。这就是最常见的SDK初始化过程。</p>\n<h3 id=\"SDK功能\"><a href=\"#SDK功能\" class=\"headerlink\" title=\"SDK功能\"></a>SDK功能</h3><p>需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。</p>\n<p>说白了就是，他们new一下就出现一个我们提供的登录框，如下图：</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/postMessage.png\" alt=\"登录组件\"></p>\n<p>初步分析</p>\n<ul>\n<li>入参:<ul>\n<li>需要指定的div的id</li>\n<li>需要成功和失败的回调函数</li>\n</ul>\n</li>\n<li>功能：<ul>\n<li>我方负责渲染页面插入指定的id的div</li>\n<li>我方服务器返回的信息要通知业务方，涉及到跨域</li>\n<li>成功以后执行回调函数</li>\n<li>销毁SDK</li>\n</ul>\n</li>\n<li>返回值：<ul>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n<p>综上，我们的SDK大概的样子就是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> SDK = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>)</span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.container = options.container;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.createBody(options);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onMessage(options.onSuccess, options.onFail);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  pro = SDK.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.createBody = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body = <span class=\"keyword\">this</span>.container;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addIframe(<span class=\"string\">'https://fdfdfdfd'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.addIframe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nIframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nIframe.src = url;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body.appendChild(<span class=\"keyword\">this</span>.nIframe);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.onMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onSuccess, onFail</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onmessage = util._$bind(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(event.data),</span><br><span class=\"line\">          ret = data.ret;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ret)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onSuccess=== <span class=\"string\">'function'</span>))&#123;</span><br><span class=\"line\">          onSuccess.call(<span class=\"keyword\">this</span>, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onFail=== <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">          onFail.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.close = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.removeChild(<span class=\"keyword\">this</span>.__body);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.NEO = NEO;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> NEO;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上就是我想要分享的组件和SDK开发思路。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"function-gt-组件-gt-sdk\"><a href=\"#function-gt-组件-gt-sdk\" class=\"headerlink\" title=\"function -&gt; 组件 -&gt; sdk\"></a>function -&gt; 组件 -&gt; sdk</h1><blockquote>\n<p>写在前面：在开发的过中很多时候都会用到组件，有的人在初期搭建了项目，有的后来就可以直接使用项目中已有的组件。但是当需求中有一个需求是项目中没有的组件，这个组件又可能是以后常用的组件，那我们只能自己动手写组件了。</p>\n</blockquote>\n<h2 id=\"组件是什么\"><a href=\"#组件是什么\" class=\"headerlink\" title=\"组件是什么\"></a>组件是什么</h2><p>我的理解是，项目中反复会用到，具有固定功能的模块。比如：弹框，日历，autocomplete，当然还有所有的表单元素。</p>\n<p>为了说的简单，就拿一个相对独立的组件弹窗来举例。如果自己需要实现一个弹窗，我们应该如同动手？</p>\n<p>回到我说的定义，组件是具有固定功能的模块，意思就是说只要我适当的使用它，它总能实现固定的功能。</p>\n<h2 id=\"组件要素\"><a href=\"#组件要素\" class=\"headerlink\" title=\"组件要素\"></a>组件要素</h2><p>那我可以抽象的认为，组件就像一个function，一个function通常的要素是什么：名字，入参，返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a * b&#125;</span><br></pre></td></tr></table></figure>\n<p>组件其实和这个很相似，举个例子，弹框组件通常是下面这个的样子。</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/component1.png\" alt=\"弹窗组件\"></p>\n<h3 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h3><ul>\n<li><p>content</p>\n<p>从图上我们很容易看出，几乎只有中间部分的内容是需要调用者自己输入的内容。其他的我们希望只要初始化这个组件，就有一个一模一样的弹窗出现。</p>\n<p>如果我们把组件当成一个function的话，那我们找到了弹窗组件需要用户输入的第一个内容：中间的内容，我们用一个变量content来表示。</p>\n</li>\n</ul>\n<ul>\n<li><p>title</p>\n<p>还有什么事需要输入的呢？没错title，我们其实不希望new一个弹窗以后出现的title是“title”，几个字，而是我们自己定义的名字，这样我们就找了第二个需要输入的变量：title。</p>\n</li>\n</ul>\n<ul>\n<li><p>点击ok按钮的回调函数</p>\n<p>通常使用者点击了弹框上面的ok按钮，代表用户同意做某个事情，那些可以执行接下来的操作，那些操作其实和弹框组件本身无关，但是点击ok按钮又必要要触发这个逻辑，那我们选择以回调函数的方式传进组件来。</p>\n</li>\n<li><p>组件宽度</p>\n</li>\n</ul>\n<h3 id=\"组件本身的功能\"><a href=\"#组件本身的功能\" class=\"headerlink\" title=\"组件本身的功能\"></a>组件本身的功能</h3><p>本身的功能是指那些不需要依赖外部参数就能完成的功能。</p>\n<ul>\n<li><p>关闭</p>\n<p>这个弹窗的右上的关闭按钮和cancel按钮点击以后通常会关闭弹窗，这个功能通常可以在组件本身完成。因为关闭弹窗不需要处理任何问题</p>\n</li>\n<li><p>初始化</p>\n<p>初始化这个组件一定会发生，因为既然是一个组件，想要使用就会初始化。</p>\n</li>\n</ul>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>组件返回其实就是就是一个弹框。</p>\n<h2 id=\"组件开发\"><a href=\"#组件开发\" class=\"headerlink\" title=\"组件开发\"></a>组件开发</h2><p>有了上面的开发，我们大致能想象出如下框架</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Modal = Regular.extend(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'modal'</span>,</span><br><span class=\"line\">    template: tpl,</span><br><span class=\"line\">    config: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      _.$extend(<span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">          title: <span class=\"string\">'title'</span>, <span class=\"comment\">//默认属性值</span></span><br><span class=\"line\">          width：<span class=\"number\">400</span>,</span><br><span class=\"line\">          content: <span class=\"string\">''</span>,</span><br><span class=\"line\">          okButton: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          cancelButton: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          visible:<span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$inject(<span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    ok: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'ok'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.destroy();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    cancel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'cancel'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>可以说所有的入参都是组件的可配置功能，入参有的必须传入的，有的是非必传的。大部分的情况我们会给某些参数写一个默认值，如果开发者在初始化的时候灭有传这个参数，就使用默认值。但也有一些必传参数无法给与默认值，必须由开发者传入。</p>\n<p>可以说这就是组件的基本架构，有传入的参数，有组件自己的变量和方法，有回调函数。</p>\n<h2 id=\"其他组件开发\"><a href=\"#其他组件开发\" class=\"headerlink\" title=\"其他组件开发\"></a>其他组件开发</h2><p>同理，我们可以分析出一个autocomplate组件架构</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/component2.png\" alt=\"autocomplate组件\"></p>\n<p>这个组件大家一定不陌生，就是复杂一点的输入框。基本功能是，当用户输入的时，能根据输入的字符匹配到联想内类展示在下面，如果用户点击或者用键盘选择某个值则联想框消失，或者输入的字符没有匹配到联想的任何内容，联想框也不会出现。最后，如果用户点击了联想框以外的地方，联想框也消失。</p>\n<p><a href=\"https://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js\" target=\"_blank\" rel=\"noopener\">https://github.com/reactjs/react-autocomplete/blob/master/lib/Autocomplete.js</a></p>\n<ul>\n<li><p>入参：</p>\n<ul>\n<li>联想的数据源items（可以是静态的，也可以是请求得到的数据）</li>\n<li>当用户选择了某个值最后的结果返回给回调函数getVal</li>\n</ul>\n</li>\n<li><p>功能：</p>\n<ul>\n<li>获取input输入的值getInputValue</li>\n<li>监听input的变化onChange</li>\n<li>监听键盘选择onSelect</li>\n<li>input失焦，则收起联想，并返回最终值onInputBlur</li>\n</ul>\n</li>\n<li><p>返回值：</p>\n<ul>\n<li>最终用户选择的联想值，如果没有选择的联想值则返回input框输入的值</li>\n</ul>\n</li>\n</ul>\n<p>所以根据上面的分析，我们组件大致是下面这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Autocomplate = Regular.extend(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'autocomplate'</span>,</span><br><span class=\"line\">    template: tpl,</span><br><span class=\"line\">    config: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      _.$extend(<span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">          items: &#123;&#125;, <span class=\"comment\">//默认属性值</span></span><br><span class=\"line\">          isOpen: <span class=\"literal\">false</span>，</span><br><span class=\"line\">          realValue：<span class=\"string\">''</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.supr();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    onChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>,<span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    onSelect: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>,<span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   onInputBlur: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.data.isOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.getRealValue();</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'getVal'</span>, <span class=\"keyword\">this</span>.data.realValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   getInputValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.input;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    getRealValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里只是写个大概，最终当然还有很多需要处理的内容。但是大体的结构也就是那三个最重要的要素。入参，功能，返回值。也就是，传入的静态变量和回调函数，组件本身的功能函数，和返回值。</p>\n<p>事实上我们很多常用的组件，都是用这样的思路写出来的，像slider，page等，但是根据功能的不同复杂程度也不同。</p>\n<h2 id=\"SDK的开发\"><a href=\"#SDK的开发\" class=\"headerlink\" title=\"SDK的开发\"></a>SDK的开发</h2><p>SDK是什么？我的理解就是具有一定功能的集合，这听起来是不是和组件很相似。没错，我觉得非常相似。</p>\n<p>下面举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> SDK(&#123;</span><br><span class=\"line\">        container: elementID,</span><br><span class=\"line\">        onSuccess: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (result.ret) &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//一些处理</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        onFail: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//一些处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br></pre></td></tr></table></figure>\n<p>这个SDK的组件有3个入参，分别是1个静态变量和两个回调函数，从onSuccess回调函数可能看出，这个这组件的返回值是result。这就是最常见的SDK初始化过程。</p>\n<h3 id=\"SDK功能\"><a href=\"#SDK功能\" class=\"headerlink\" title=\"SDK功能\"></a>SDK功能</h3><p>需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。</p>\n<p>说白了就是，他们new一下就出现一个我们提供的登录框，如下图：</p>\n<p><img src=\"/2018/06/08/function-组件-sdk/postMessage.png\" alt=\"登录组件\"></p>\n<p>初步分析</p>\n<ul>\n<li>入参:<ul>\n<li>需要指定的div的id</li>\n<li>需要成功和失败的回调函数</li>\n</ul>\n</li>\n<li>功能：<ul>\n<li>我方负责渲染页面插入指定的id的div</li>\n<li>我方服务器返回的信息要通知业务方，涉及到跨域</li>\n<li>成功以后执行回调函数</li>\n<li>销毁SDK</li>\n</ul>\n</li>\n<li>返回值：<ul>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n<p>综上，我们的SDK大概的样子就是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> SDK = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>)</span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.container = options.container;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.createBody(options);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onMessage(options.onSuccess, options.onFail);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  pro = SDK.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.createBody = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body = <span class=\"keyword\">this</span>.container;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addIframe(<span class=\"string\">'https://fdfdfdfd'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.addIframe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nIframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nIframe.src = url;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body.appendChild(<span class=\"keyword\">this</span>.nIframe);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.onMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onSuccess, onFail</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onmessage = util._$bind(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(event.data),</span><br><span class=\"line\">          ret = data.ret;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ret)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onSuccess=== <span class=\"string\">'function'</span>))&#123;</span><br><span class=\"line\">          onSuccess.call(<span class=\"keyword\">this</span>, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onFail=== <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">          onFail.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pro.close = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.removeChild(<span class=\"keyword\">this</span>.__body);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.NEO = NEO;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> NEO;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上就是我想要分享的组件和SDK开发思路。</p>\n"},{"title":"'理解正则表达式'","date":"2018-06-12T08:16:37.000Z","_content":"\n\n# 理解正则表达式\n\n> 写在前面：正则表达式对于前端开发来说不陌生，虽然使用的频率不是很高，但也难免遇到。可是每次看着网上的解释，我都很头痛。知道项目组中有大神，我决定向大神取经，带我入门。这次的目标就是读懂下面一个表达式：`/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/`。这个表达式是从网上找来的。希望通过这次的学习，可以读懂。\n\n\n\n## 正则表达式是什么\n\n描述了一种字符串匹配的模式。\n\n这样听起来非常抽象，我的理解是，一系列的规则，可以判断字符串是否符合规则。\n\n常见正则表达式如下：\n\n* `/^(13|14|15|17|18)\\d{9}$/`  匹配手机号\n* `/^([\\w\\.-]+)@[\\w][\\w\\.-]*[\\w]\\.([a-zA-Z]{2,6})$/`  匹配邮箱\n* `/^[0-9]{6}$/`  匹配短信验证码\n\n用最简单的一个来举例`/^[0-9]{6}$/`，看下这个是怎么组成的\n\n![理解正则表达式图1](理解正则表达式/reg.png)\n\n可以看到，一般的的这则表达式大致由三个部分组成，中括号包起来的字符集，花括号包起来的限定符，以及一些表示特定意思的特殊字符。\n\n**字符集**:表示匹配的字符的集合，上面的例子表示，0,1,2,3,4,5,6,7,8,9\n\n**限定符**：表示对前面的字符集进行某种限定，上面的例子，表示只能是6个字符\n\n**特殊字符**:**^**表示匹配输入字符串的开始位置\n\n**特殊字符**:**$**表示匹配输入字符串的结束位置\n\n所以所有的连接起来的意思是只能是0-9中的6个数字组成的字符串。如094567,547845，这种就是符合规则的，dfd456这种就不符合规格。\n\n\n\n## 进阶\n\n看了上面的例子，感觉好像懂了。然而回头看看这篇文章的目标\n\n```js\n/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.-A-Za-z]+)(?::(\\d+))?(?:\\/(?#))?(?:\\?(#))?(?:#(.*))?$/\n```\n\n是不是感觉一脸懵逼，百脸懵逼，我是谁？我在哪里？······\n\n接下来，为了能解说这个正则表达式，我们再来学习一些符号。\n\n### ()\n\n查阅网站得到如下解说：`标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用`\n\n看了又是一脸懵逼，什么意思？\n\n举个栗子：一个匹配网站二级域名的正则表达式如下：\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\",\"123.com\",\":8080\"]\n\n```\n\n经过观察，这个正则表达式与第一个例子表达式有个很重要的区别，就是有（）。看到上面的结果，可以看出exec返回一个数组，数组的第二值就是我们想要的域名。为什么是第二个呢？\n\n有的文章解释说：括号被称为 捕获括号。我们把括号去掉，得到如下表达式:\n\n```js\nvar regParentHost = /^.+\\.\\w+\\.\\w+:.*$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"]\n```\n\n结果如上，没有返回域名和端口号，而加上了两个小括号，就会得到3个结果。\n\n我们来尝试添加一个（）\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+):.*$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\",\"123.com\"]\n```\n\n结果如我所想，返回了两个值。这样我们再看`标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用`\n\n这个解释好像能明白一些。如果出现括号，则认为是一个子表达式，如果字符串中有满足子表达式的，将这些字符串保存起来，最后可以以数组的形式返回。如果括号中的子表达式没有被匹配到，就返回undefined。\n\n也就是说有几个（）就会有几个结果返回。\n\n### ?\n\n说完（），就来说重头戏问号。\n\n#### ?用法1:\n\n#### 匹配前面一个表达式0次或者1次。等价于 {0,1}\n\n查阅网站，解说如下：匹配前面一个表达式0次或者1次。等价于 {0,1}。\n\n还是这个栗子：\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n```\n\n后半段`(:.*)?`括号后面有个问号。\n\n`：`表示匹配‘：’，\n\n`.`号表示匹配除“`\\r`”“`\\n`”之外的任何单个字符，\n\n`*`表示匹配前面的子表达式零次或多次。\n\n括号里面连起来就是，匹配：后面的所有字符零次或多次。\n\n然后`？`表示匹配前面一个表达式0次或者1次，换一种说法就是，匹配前面一个表达式有或者没有。\n\n有问号没问号什么区别？看例子：\n\n```js\nvar regParentHost2 = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost2.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n-------------------------------------------------------------\n\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)？$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n-------------------------------------------------------------\n\nvar regParentHost2 = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost2.exec('https://xxdfd.163.123.com')\n\n// null\n------------------------------------------------------------\n\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)？$/\n\nregParentHost.exec('https://xxdfd.163.123.com')\n\n// [\"https://xxdfd.163.123.com\"，\"123.com\"，undefined]\n\n```\n\n从上面的例子可以看出来，在测试'htttps://xxdfd.163.123.com:8080' 这个字符串的时候，两者返回的没有区别，但是测试'htttps://xxdfd.163.123.com' 这字符串的时候返回的不一样，一个是在返回的数组中的第三个位置返回undefined，一个直接是null。因为正则表达式中如果有`？` 就表示，有也可以，没有也可以。所以上面的例子中字符串中有没有`：` 都可以匹配成功。如果没有`？` 则表示字符串中一定要有`：` 否则就匹配失败。\n\n上面栗子的正则表达式的目的是提取一个网站的主域名。明眼人一看就知道，这个正则不能达到目的，因为，很多的网站的端口号是默认的，并没有显示出来，像这样'htttps://xxdfd.163.123.com/abc' ，测试结果如下\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n\nregParentHost.exec('https://xxdfd.163.123.com/abc')\n\n//null\n```\n\n果然无法匹配。怎么修改？其实我们已经大致有方向了。\n\n既然是通常的网站，我们可以匹配`：` 后面是数字，数字后面是`/` ,斜杠后面是任意字符\n\n大致的样子就是下面这样\n\n```js\nvar regParentHostNew = /^.+\\.(\\w+\\.\\w+)(:\\d+)?(\\/.+)?$/\n\nregParentHostNew.exec('https://xxdfd.163.123.com/abc')\n\n// [\"https://xxdfd.163.123.com/abc\", \"123.com\", undefined, \"/abc\"]\n-------------------------------------------------------------------------\n\n\nregParentHostNew.exec('https://xxdfd.163.123.com:8080/abc')\n\n// [\"https://xxdfd.163.123.com:8080/abc\", \"123.com\", \":8080\", \"/abc\"]\n```\n\n修改的就是加上了匹配冒号后的一个或者多个数字，匹配/后面的任意字符。\n\n\n\n上面的例子还没有说完，为什么`(\\w+\\.\\w+)` 中就可以匹配二级域名？\n\n我们引入另一个有关问号的关键概念：**非贪婪** 和**贪婪模式**。\n\n\n\n#### ?用法2:\n\n#### 如果**紧跟在任何量词 \\*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**的（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。\n\n再看例子`/^.+\\.(\\w+\\.\\w+)(:.*)$/` 中前面的部分`.+\\.` ，\n\n`.` 表示匹配除`\\r`，`\\n`之外的任何单个字符，\n\n`+ ` 可以理解为量词，表示匹配前面一个表达式1次或者多次，\n\n`\\.` 匹配点号。\n\n连起来的意思是，匹配任意字符直到点号，那么'htttps://xxdfd.163.123.com/abc' 中，匹配的应该是'https://xxdfdf.'。\n\n再看后面`(\\w+\\.\\w+)` ，\n\n`\\w`匹配一个单字字符（字母、数字或者下划线）,\n\n`+` 量词，表示匹配前面一个表达式1次或者多次,\n\n`\\.` 匹配点号，\n\n`\\w+` 匹配一个单字字符（字母、数字或者下划线)1次或者多次，\n\n`(\\w+\\.\\w+)` 连起来就是匹配xxxx.xxxxx这样的字符串。\n\n根据上面的分析，`(\\w+\\.\\w+)` 匹配到的应该是`163.123` 才对，可是结果却是`123.com` \n\n这是为何？原来忽略了**非贪婪** 和**贪婪模式** 。\n\n`.+\\.` 其中有个量词`+` ,这个加号后面没有跟随一个`?` 则说明处于**贪婪模式** 。这个模式下可以匹配尽可能多的字符。怎么理解呢？\n\n`.+\\.` 意思是匹配任意字符直到`.` ,在非贪婪模式下可以匹配到'htttps://xxdfd.163.123.' ，因为点号前面的都可以看成是任意字符，但是，紧接着后面的`(\\w+\\.\\w+)`,需要匹配xxxx.xxxxx，且（）的优先级比较高，所以，优先匹配了'123.com'，最终，`.+\\.` 就匹配了'htttps://xxdfd.163' 。\n\n为了证实这个说法，我们可以使用非贪婪模式验证一下\n\n```js\n'https://xxdfd.163.123.com:8080/dfdf'.match(/^.+?\\.(\\w+\\.\\w+).+$/)\n\n// [\"https://xxdfd.163.123.com:8080/dfdf\", \"163.123\"]\n```\n\n可以看到，结果就变成\"163.123\"。\n\n\n\n### （？：pattern）\n\n前面的正则表达式中返回的端口号前面有个冒号。\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n\n```\n\n数组第三个元素值是’：8080‘，如果我们不想要其中的’：‘怎么做呢？\n\n下面隆重推出`？` 和其他搭配使用的第一种，和冒号搭配。\n\n查阅网站，得到如下解说`（？：pattern）` ：匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。\n\n举个栗子：\n\n```js\n/^(aaa)(?:b)(ccc)$/.exec('aaabccc')\n\n// [\"aaabccc\", \"aaa\", \"ccc\"]\n```\n\n```js\n/^(aaa)(b)(ccc)$/.exec('aaabccc')\n\n // [\"aaabccc\", \"aaa\", \"b\", \"ccc\"]\n```\n\n上面两个唯一不同的地方就是b是被（？：pattern）这样的表达式包围的，再看看之前的解说，匹配pattern但不获取匹配的子字符串，这里就是匹配字母b，但是不会作为结果返回。\n\n所以`/^.+\\.(\\w+\\.\\w+)(:.*)$/` 这个正则表达式如果想要匹配到冒号，但是不输出，可以使用（？：pattern）的语法。\n\n```js\n/^.+\\.(\\w+\\.\\w+)(?::(.*))$/.exec('https://xxxxxxx.163.126.com:8080')\n\n// [\"https://xxxxxxx.163.126.com:8080\", \"126.com\", \"8080\"]\n```\n\n知道以上的几个知识点，已经可以解答这个文章最终的正则表达式了。但是为了我以后能更好的理解正则表达式，大神还给我补充了以下知识点\n\n\n\n### x(?=y)\n\n匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。\n\n如：\n\n```js\n/Jack(?=Sprat)/.exec('JackSprat')\n\n// [\"Jack\"]\n---------------------------------------\n\n/Jack(?=Sprat)/.exec('JackSpraa')\n// null\n```\n\n/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n还有一个例子：\n\n```js\n/aaa(?=bb)bbc/.exec('aaabbc')\n\n// [\"aaabbc\"]\n-----------------------------------\n\n/aaa(?=bb)c/.exec('aaabbc')\n// null\n```\n\n这个例子可以看出，匹配aaa，后面必须是bb，但是(?=bb)后面的表达式却是从aaa后面开始匹配，并不是从bb后开始。使用的时候应该注意。\n\n\n\n### x(?!y)\n\n匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。也就是非的意思。\n\n```js\n/aaa(?!bb)/.exec('aaab')\n\n// [\"aaa\"]\n---------------------------------\n/aaa(?!bb)/.exec('aaabb')\n\n// null\n```\n\n同样\n\n```js\n/aaa(?!bb)c/.exec('aaac')\n\n// [\"aaac\"]\n---------------------------------\n/aaa(?!bb)c/.exec('aaam')\n\n// null\n```\n\n匹配aaa，后面不能是bb，但是(?！bb)后面的表达式却是从aaa后面开始匹配。使用时候应该注意。\n\n\n\n## 解惑\n\n最后我们来解读下文章开头的正则表达式\n\n`/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/`\n\n我们先按照小括号一部分一部分的拆开：\n\n1. `(?:  ([A-Za-z]+):)?`\n\n   `[a-zA-Z]` 英文字母，\n\n   `+` 量词，匹配前面表达式1次或者多次，\n\n   `：` 匹配冒号\n\n   连起来就是，匹配'abc:'\n\n2. `(\\/{0,3})`\n\n   `\\/` 匹配'/'\n\n   `{0,3}` 量词，匹配前面表达式0到3次，\n\n   连起来就是，匹配'///'\n\n3. `([0-9.\\-A-Za-z]+) ` \n\n   `0-9` 匹配数字\n\n   `.` 中括号里面的点表示点号本身‘.’\n\n   `\\-` 匹配短横线‘-’\n\n   `A-Za-z` 字母\n\n   `+` 匹配一次或多次，后面没有‘？’，所以使用贪婪模式，尽量匹配多的字符串。\n\n   连起来就是，匹配字母或者数字'.'或者‘-’，匹配‘abc0123.dfdfdf’\n\n4. `(?:  :(\\d+))?` \n\n   `:` 匹配冒号\n\n   `(\\d+)` 匹配数字，尽可能多的匹配\n\n   `(?:  :）` 匹配冒号，但是冒号不作为结果返回\n\n   连起来就是，匹配‘:8080’这样的字符串，然后返回的只有‘8080’。\n\n5. `(?:  \\/([^?#]*))?`\n\n   ` \\/` 匹配‘/’\n\n   `[^?#]` 匹配所有字符除了‘？’或者‘#’\n\n   `*` 量词，匹配前一个表达式0次或多次\n\n   `(?:  \\/)` 匹配‘/’,但不作为结果输出\n\n   连起来就是，匹配斜杠后面的任意字符直到遇到'？'或者'#'，也就是'/aaaa',返回'aaaa'。\n\n6. `(?:   \\?([^#]*))?`\n\n   `\\?` 匹配问号’？‘\n\n   `[^#]` 匹配所有字符除了‘#’\n\n   `*` 量词，匹配前一个表达式0次或多次\n\n   `(?:  \\?)` 匹配‘？’,但不作为结果输出\n\n   连起来就是，匹配问号后面的任意字符直到遇到‘#’，也就是'?c=4',返回’c=4‘。\n\n7. `(?:  #(.*))?`\n\n   `#` 匹配’#‘\n\n   `.` 匹配除换行符 \\n 之外的任何单字符\n\n   `*` 量词，匹配前面的子表达式零次或多次，默认匹配多次\n\n   `(?:   #)  ` 匹配’#‘号但是不作为返回值\n\n   连起来就是，匹配#号后面任意字符，也就是，’#bbb‘，返回’bbb‘\n\n综上，整个表达式就是匹配**'htttps://domain.com:1000/ac/asdasdf?query=xx#dasf'** 这样的字符串，并且返回字符串的各个部分。\n\n\n```js\n/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/\n.exec('https://domain.com:1000/ac/asdasdf?query=xx#dasf')\n\n// [\"https://domain.com:1000/ac/asdasdf?query=xx#dasf\"\n\n// , \"https\", \"//\", \"domain.com\", \"1000\", \"ac/asdasdf\", \"query=xx\", \"dasf\"]\nhttps://domain.com:1000/ac/asdasdf?query=xx#dasf\n```\n\n看到这里，我想已经能看懂大部分的正则表达式了。还有什么看不懂的可以自己查阅资料来学习。\n\n","source":"_posts/理解正则表达式.md","raw":"---\ntitle: '''理解正则表达式'''\ndate: 2018-06-12 16:16:37\ntags:\n- 前端\n- js\n- 正则表达式\n---\n\n\n# 理解正则表达式\n\n> 写在前面：正则表达式对于前端开发来说不陌生，虽然使用的频率不是很高，但也难免遇到。可是每次看着网上的解释，我都很头痛。知道项目组中有大神，我决定向大神取经，带我入门。这次的目标就是读懂下面一个表达式：`/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/`。这个表达式是从网上找来的。希望通过这次的学习，可以读懂。\n\n\n\n## 正则表达式是什么\n\n描述了一种字符串匹配的模式。\n\n这样听起来非常抽象，我的理解是，一系列的规则，可以判断字符串是否符合规则。\n\n常见正则表达式如下：\n\n* `/^(13|14|15|17|18)\\d{9}$/`  匹配手机号\n* `/^([\\w\\.-]+)@[\\w][\\w\\.-]*[\\w]\\.([a-zA-Z]{2,6})$/`  匹配邮箱\n* `/^[0-9]{6}$/`  匹配短信验证码\n\n用最简单的一个来举例`/^[0-9]{6}$/`，看下这个是怎么组成的\n\n![理解正则表达式图1](理解正则表达式/reg.png)\n\n可以看到，一般的的这则表达式大致由三个部分组成，中括号包起来的字符集，花括号包起来的限定符，以及一些表示特定意思的特殊字符。\n\n**字符集**:表示匹配的字符的集合，上面的例子表示，0,1,2,3,4,5,6,7,8,9\n\n**限定符**：表示对前面的字符集进行某种限定，上面的例子，表示只能是6个字符\n\n**特殊字符**:**^**表示匹配输入字符串的开始位置\n\n**特殊字符**:**$**表示匹配输入字符串的结束位置\n\n所以所有的连接起来的意思是只能是0-9中的6个数字组成的字符串。如094567,547845，这种就是符合规则的，dfd456这种就不符合规格。\n\n\n\n## 进阶\n\n看了上面的例子，感觉好像懂了。然而回头看看这篇文章的目标\n\n```js\n/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.-A-Za-z]+)(?::(\\d+))?(?:\\/(?#))?(?:\\?(#))?(?:#(.*))?$/\n```\n\n是不是感觉一脸懵逼，百脸懵逼，我是谁？我在哪里？······\n\n接下来，为了能解说这个正则表达式，我们再来学习一些符号。\n\n### ()\n\n查阅网站得到如下解说：`标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用`\n\n看了又是一脸懵逼，什么意思？\n\n举个栗子：一个匹配网站二级域名的正则表达式如下：\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\",\"123.com\",\":8080\"]\n\n```\n\n经过观察，这个正则表达式与第一个例子表达式有个很重要的区别，就是有（）。看到上面的结果，可以看出exec返回一个数组，数组的第二值就是我们想要的域名。为什么是第二个呢？\n\n有的文章解释说：括号被称为 捕获括号。我们把括号去掉，得到如下表达式:\n\n```js\nvar regParentHost = /^.+\\.\\w+\\.\\w+:.*$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"]\n```\n\n结果如上，没有返回域名和端口号，而加上了两个小括号，就会得到3个结果。\n\n我们来尝试添加一个（）\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+):.*$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\",\"123.com\"]\n```\n\n结果如我所想，返回了两个值。这样我们再看`标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用`\n\n这个解释好像能明白一些。如果出现括号，则认为是一个子表达式，如果字符串中有满足子表达式的，将这些字符串保存起来，最后可以以数组的形式返回。如果括号中的子表达式没有被匹配到，就返回undefined。\n\n也就是说有几个（）就会有几个结果返回。\n\n### ?\n\n说完（），就来说重头戏问号。\n\n#### ?用法1:\n\n#### 匹配前面一个表达式0次或者1次。等价于 {0,1}\n\n查阅网站，解说如下：匹配前面一个表达式0次或者1次。等价于 {0,1}。\n\n还是这个栗子：\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n```\n\n后半段`(:.*)?`括号后面有个问号。\n\n`：`表示匹配‘：’，\n\n`.`号表示匹配除“`\\r`”“`\\n`”之外的任何单个字符，\n\n`*`表示匹配前面的子表达式零次或多次。\n\n括号里面连起来就是，匹配：后面的所有字符零次或多次。\n\n然后`？`表示匹配前面一个表达式0次或者1次，换一种说法就是，匹配前面一个表达式有或者没有。\n\n有问号没问号什么区别？看例子：\n\n```js\nvar regParentHost2 = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost2.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n-------------------------------------------------------------\n\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)？$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n-------------------------------------------------------------\n\nvar regParentHost2 = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost2.exec('https://xxdfd.163.123.com')\n\n// null\n------------------------------------------------------------\n\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)？$/\n\nregParentHost.exec('https://xxdfd.163.123.com')\n\n// [\"https://xxdfd.163.123.com\"，\"123.com\"，undefined]\n\n```\n\n从上面的例子可以看出来，在测试'htttps://xxdfd.163.123.com:8080' 这个字符串的时候，两者返回的没有区别，但是测试'htttps://xxdfd.163.123.com' 这字符串的时候返回的不一样，一个是在返回的数组中的第三个位置返回undefined，一个直接是null。因为正则表达式中如果有`？` 就表示，有也可以，没有也可以。所以上面的例子中字符串中有没有`：` 都可以匹配成功。如果没有`？` 则表示字符串中一定要有`：` 否则就匹配失败。\n\n上面栗子的正则表达式的目的是提取一个网站的主域名。明眼人一看就知道，这个正则不能达到目的，因为，很多的网站的端口号是默认的，并没有显示出来，像这样'htttps://xxdfd.163.123.com/abc' ，测试结果如下\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)?$/\n\nregParentHost.exec('https://xxdfd.163.123.com/abc')\n\n//null\n```\n\n果然无法匹配。怎么修改？其实我们已经大致有方向了。\n\n既然是通常的网站，我们可以匹配`：` 后面是数字，数字后面是`/` ,斜杠后面是任意字符\n\n大致的样子就是下面这样\n\n```js\nvar regParentHostNew = /^.+\\.(\\w+\\.\\w+)(:\\d+)?(\\/.+)?$/\n\nregParentHostNew.exec('https://xxdfd.163.123.com/abc')\n\n// [\"https://xxdfd.163.123.com/abc\", \"123.com\", undefined, \"/abc\"]\n-------------------------------------------------------------------------\n\n\nregParentHostNew.exec('https://xxdfd.163.123.com:8080/abc')\n\n// [\"https://xxdfd.163.123.com:8080/abc\", \"123.com\", \":8080\", \"/abc\"]\n```\n\n修改的就是加上了匹配冒号后的一个或者多个数字，匹配/后面的任意字符。\n\n\n\n上面的例子还没有说完，为什么`(\\w+\\.\\w+)` 中就可以匹配二级域名？\n\n我们引入另一个有关问号的关键概念：**非贪婪** 和**贪婪模式**。\n\n\n\n#### ?用法2:\n\n#### 如果**紧跟在任何量词 \\*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**的（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。\n\n再看例子`/^.+\\.(\\w+\\.\\w+)(:.*)$/` 中前面的部分`.+\\.` ，\n\n`.` 表示匹配除`\\r`，`\\n`之外的任何单个字符，\n\n`+ ` 可以理解为量词，表示匹配前面一个表达式1次或者多次，\n\n`\\.` 匹配点号。\n\n连起来的意思是，匹配任意字符直到点号，那么'htttps://xxdfd.163.123.com/abc' 中，匹配的应该是'https://xxdfdf.'。\n\n再看后面`(\\w+\\.\\w+)` ，\n\n`\\w`匹配一个单字字符（字母、数字或者下划线）,\n\n`+` 量词，表示匹配前面一个表达式1次或者多次,\n\n`\\.` 匹配点号，\n\n`\\w+` 匹配一个单字字符（字母、数字或者下划线)1次或者多次，\n\n`(\\w+\\.\\w+)` 连起来就是匹配xxxx.xxxxx这样的字符串。\n\n根据上面的分析，`(\\w+\\.\\w+)` 匹配到的应该是`163.123` 才对，可是结果却是`123.com` \n\n这是为何？原来忽略了**非贪婪** 和**贪婪模式** 。\n\n`.+\\.` 其中有个量词`+` ,这个加号后面没有跟随一个`?` 则说明处于**贪婪模式** 。这个模式下可以匹配尽可能多的字符。怎么理解呢？\n\n`.+\\.` 意思是匹配任意字符直到`.` ,在非贪婪模式下可以匹配到'htttps://xxdfd.163.123.' ，因为点号前面的都可以看成是任意字符，但是，紧接着后面的`(\\w+\\.\\w+)`,需要匹配xxxx.xxxxx，且（）的优先级比较高，所以，优先匹配了'123.com'，最终，`.+\\.` 就匹配了'htttps://xxdfd.163' 。\n\n为了证实这个说法，我们可以使用非贪婪模式验证一下\n\n```js\n'https://xxdfd.163.123.com:8080/dfdf'.match(/^.+?\\.(\\w+\\.\\w+).+$/)\n\n// [\"https://xxdfd.163.123.com:8080/dfdf\", \"163.123\"]\n```\n\n可以看到，结果就变成\"163.123\"。\n\n\n\n### （？：pattern）\n\n前面的正则表达式中返回的端口号前面有个冒号。\n\n```js\nvar regParentHost = /^.+\\.(\\w+\\.\\w+)(:.*)$/\n\nregParentHost.exec('https://xxdfd.163.123.com:8080')\n\n// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]\n\n```\n\n数组第三个元素值是’：8080‘，如果我们不想要其中的’：‘怎么做呢？\n\n下面隆重推出`？` 和其他搭配使用的第一种，和冒号搭配。\n\n查阅网站，得到如下解说`（？：pattern）` ：匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。\n\n举个栗子：\n\n```js\n/^(aaa)(?:b)(ccc)$/.exec('aaabccc')\n\n// [\"aaabccc\", \"aaa\", \"ccc\"]\n```\n\n```js\n/^(aaa)(b)(ccc)$/.exec('aaabccc')\n\n // [\"aaabccc\", \"aaa\", \"b\", \"ccc\"]\n```\n\n上面两个唯一不同的地方就是b是被（？：pattern）这样的表达式包围的，再看看之前的解说，匹配pattern但不获取匹配的子字符串，这里就是匹配字母b，但是不会作为结果返回。\n\n所以`/^.+\\.(\\w+\\.\\w+)(:.*)$/` 这个正则表达式如果想要匹配到冒号，但是不输出，可以使用（？：pattern）的语法。\n\n```js\n/^.+\\.(\\w+\\.\\w+)(?::(.*))$/.exec('https://xxxxxxx.163.126.com:8080')\n\n// [\"https://xxxxxxx.163.126.com:8080\", \"126.com\", \"8080\"]\n```\n\n知道以上的几个知识点，已经可以解答这个文章最终的正则表达式了。但是为了我以后能更好的理解正则表达式，大神还给我补充了以下知识点\n\n\n\n### x(?=y)\n\n匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。\n\n如：\n\n```js\n/Jack(?=Sprat)/.exec('JackSprat')\n\n// [\"Jack\"]\n---------------------------------------\n\n/Jack(?=Sprat)/.exec('JackSpraa')\n// null\n```\n\n/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n还有一个例子：\n\n```js\n/aaa(?=bb)bbc/.exec('aaabbc')\n\n// [\"aaabbc\"]\n-----------------------------------\n\n/aaa(?=bb)c/.exec('aaabbc')\n// null\n```\n\n这个例子可以看出，匹配aaa，后面必须是bb，但是(?=bb)后面的表达式却是从aaa后面开始匹配，并不是从bb后开始。使用的时候应该注意。\n\n\n\n### x(?!y)\n\n匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。也就是非的意思。\n\n```js\n/aaa(?!bb)/.exec('aaab')\n\n// [\"aaa\"]\n---------------------------------\n/aaa(?!bb)/.exec('aaabb')\n\n// null\n```\n\n同样\n\n```js\n/aaa(?!bb)c/.exec('aaac')\n\n// [\"aaac\"]\n---------------------------------\n/aaa(?!bb)c/.exec('aaam')\n\n// null\n```\n\n匹配aaa，后面不能是bb，但是(?！bb)后面的表达式却是从aaa后面开始匹配。使用时候应该注意。\n\n\n\n## 解惑\n\n最后我们来解读下文章开头的正则表达式\n\n`/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/`\n\n我们先按照小括号一部分一部分的拆开：\n\n1. `(?:  ([A-Za-z]+):)?`\n\n   `[a-zA-Z]` 英文字母，\n\n   `+` 量词，匹配前面表达式1次或者多次，\n\n   `：` 匹配冒号\n\n   连起来就是，匹配'abc:'\n\n2. `(\\/{0,3})`\n\n   `\\/` 匹配'/'\n\n   `{0,3}` 量词，匹配前面表达式0到3次，\n\n   连起来就是，匹配'///'\n\n3. `([0-9.\\-A-Za-z]+) ` \n\n   `0-9` 匹配数字\n\n   `.` 中括号里面的点表示点号本身‘.’\n\n   `\\-` 匹配短横线‘-’\n\n   `A-Za-z` 字母\n\n   `+` 匹配一次或多次，后面没有‘？’，所以使用贪婪模式，尽量匹配多的字符串。\n\n   连起来就是，匹配字母或者数字'.'或者‘-’，匹配‘abc0123.dfdfdf’\n\n4. `(?:  :(\\d+))?` \n\n   `:` 匹配冒号\n\n   `(\\d+)` 匹配数字，尽可能多的匹配\n\n   `(?:  :）` 匹配冒号，但是冒号不作为结果返回\n\n   连起来就是，匹配‘:8080’这样的字符串，然后返回的只有‘8080’。\n\n5. `(?:  \\/([^?#]*))?`\n\n   ` \\/` 匹配‘/’\n\n   `[^?#]` 匹配所有字符除了‘？’或者‘#’\n\n   `*` 量词，匹配前一个表达式0次或多次\n\n   `(?:  \\/)` 匹配‘/’,但不作为结果输出\n\n   连起来就是，匹配斜杠后面的任意字符直到遇到'？'或者'#'，也就是'/aaaa',返回'aaaa'。\n\n6. `(?:   \\?([^#]*))?`\n\n   `\\?` 匹配问号’？‘\n\n   `[^#]` 匹配所有字符除了‘#’\n\n   `*` 量词，匹配前一个表达式0次或多次\n\n   `(?:  \\?)` 匹配‘？’,但不作为结果输出\n\n   连起来就是，匹配问号后面的任意字符直到遇到‘#’，也就是'?c=4',返回’c=4‘。\n\n7. `(?:  #(.*))?`\n\n   `#` 匹配’#‘\n\n   `.` 匹配除换行符 \\n 之外的任何单字符\n\n   `*` 量词，匹配前面的子表达式零次或多次，默认匹配多次\n\n   `(?:   #)  ` 匹配’#‘号但是不作为返回值\n\n   连起来就是，匹配#号后面任意字符，也就是，’#bbb‘，返回’bbb‘\n\n综上，整个表达式就是匹配**'htttps://domain.com:1000/ac/asdasdf?query=xx#dasf'** 这样的字符串，并且返回字符串的各个部分。\n\n\n```js\n/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/\n.exec('https://domain.com:1000/ac/asdasdf?query=xx#dasf')\n\n// [\"https://domain.com:1000/ac/asdasdf?query=xx#dasf\"\n\n// , \"https\", \"//\", \"domain.com\", \"1000\", \"ac/asdasdf\", \"query=xx\", \"dasf\"]\nhttps://domain.com:1000/ac/asdasdf?query=xx#dasf\n```\n\n看到这里，我想已经能看懂大部分的正则表达式了。还有什么看不懂的可以自己查阅资料来学习。\n\n","slug":"理解正则表达式","published":1,"updated":"2018-06-12T08:40:24.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzcj6000r5ois568jcb2f","content":"<h1 id=\"理解正则表达式\"><a href=\"#理解正则表达式\" class=\"headerlink\" title=\"理解正则表达式\"></a>理解正则表达式</h1><blockquote>\n<p>写在前面：正则表达式对于前端开发来说不陌生，虽然使用的频率不是很高，但也难免遇到。可是每次看着网上的解释，我都很头痛。知道项目组中有大神，我决定向大神取经，带我入门。这次的目标就是读懂下面一个表达式：<code>/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</code>。这个表达式是从网上找来的。希望通过这次的学习，可以读懂。</p>\n</blockquote>\n<h2 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h2><p>描述了一种字符串匹配的模式。</p>\n<p>这样听起来非常抽象，我的理解是，一系列的规则，可以判断字符串是否符合规则。</p>\n<p>常见正则表达式如下：</p>\n<ul>\n<li><code>/^(13|14|15|17|18)\\d{9}$/</code>  匹配手机号</li>\n<li><code>/^([\\w\\.-]+)@[\\w][\\w\\.-]*[\\w]\\.([a-zA-Z]{2,6})$/</code>  匹配邮箱</li>\n<li><code>/^[0-9]{6}$/</code>  匹配短信验证码</li>\n</ul>\n<p>用最简单的一个来举例<code>/^[0-9]{6}$/</code>，看下这个是怎么组成的</p>\n<p><img src=\"/2018/06/12/理解正则表达式/reg.png\" alt=\"理解正则表达式图1\"></p>\n<p>可以看到，一般的的这则表达式大致由三个部分组成，中括号包起来的字符集，花括号包起来的限定符，以及一些表示特定意思的特殊字符。</p>\n<p><strong>字符集</strong>:表示匹配的字符的集合，上面的例子表示，0,1,2,3,4,5,6,7,8,9</p>\n<p><strong>限定符</strong>：表示对前面的字符集进行某种限定，上面的例子，表示只能是6个字符</p>\n<p><strong>特殊字符</strong>:<strong>^</strong>表示匹配输入字符串的开始位置</p>\n<p><strong>特殊字符</strong>:<strong>$</strong>表示匹配输入字符串的结束位置</p>\n<p>所以所有的连接起来的意思是只能是0-9中的6个数字组成的字符串。如094567,547845，这种就是符合规则的，dfd456这种就不符合规格。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>看了上面的例子，感觉好像懂了。然而回头看看这篇文章的目标</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.-A-Za-z]+)(?::(\\d+))?(?:\\/(?#))?(?:\\?(#))?(?:#(.*))?$/</span><br></pre></td></tr></table></figure>\n<p>是不是感觉一脸懵逼，百脸懵逼，我是谁？我在哪里？······</p>\n<p>接下来，为了能解说这个正则表达式，我们再来学习一些符号。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"()\"></a>()</h3><p>查阅网站得到如下解说：<code>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</code></p>\n<p>看了又是一脸懵逼，什么意思？</p>\n<p>举个栗子：一个匹配网站二级域名的正则表达式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\",\"123.com\",\":8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>经过观察，这个正则表达式与第一个例子表达式有个很重要的区别，就是有（）。看到上面的结果，可以看出exec返回一个数组，数组的第二值就是我们想要的域名。为什么是第二个呢？</p>\n<p>有的文章解释说：括号被称为 捕获括号。我们把括号去掉，得到如下表达式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.\\w+\\.\\w+:.*$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果如上，没有返回域名和端口号，而加上了两个小括号，就会得到3个结果。</p>\n<p>我们来尝试添加一个（）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+):.*$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\",\"123.com\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果如我所想，返回了两个值。这样我们再看<code>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</code></p>\n<p>这个解释好像能明白一些。如果出现括号，则认为是一个子表达式，如果字符串中有满足子表达式的，将这些字符串保存起来，最后可以以数组的形式返回。如果括号中的子表达式没有被匹配到，就返回undefined。</p>\n<p>也就是说有几个（）就会有几个结果返回。</p>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"?\"></a>?</h3><p>说完（），就来说重头戏问号。</p>\n<h4 id=\"用法1\"><a href=\"#用法1\" class=\"headerlink\" title=\"?用法1:\"></a>?用法1:</h4><h4 id=\"匹配前面一个表达式0次或者1次。等价于-0-1\"><a href=\"#匹配前面一个表达式0次或者1次。等价于-0-1\" class=\"headerlink\" title=\"匹配前面一个表达式0次或者1次。等价于 {0,1}\"></a>匹配前面一个表达式0次或者1次。等价于 {0,1}</h4><p>查阅网站，解说如下：匹配前面一个表达式0次或者1次。等价于 {0,1}。</p>\n<p>还是这个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br></pre></td></tr></table></figure>\n<p>后半段<code>(:.*)?</code>括号后面有个问号。</p>\n<p><code>：</code>表示匹配‘：’，</p>\n<p><code>.</code>号表示匹配除“<code>\\r</code>”“<code>\\n</code>”之外的任何单个字符，</p>\n<p><code>*</code>表示匹配前面的子表达式零次或多次。</p>\n<p>括号里面连起来就是，匹配：后面的所有字符零次或多次。</p>\n<p>然后<code>？</code>表示匹配前面一个表达式0次或者1次，换一种说法就是，匹配前面一个表达式有或者没有。</p>\n<p>有问号没问号什么区别？看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost2 = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost2.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)？$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost2 = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost2.exec(<span class=\"string\">'https://xxdfd.163.123.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)？$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com\"，\"123.com\"，undefined]</span></span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出来，在测试’htttps://xxdfd.163.123.com:8080’ 这个字符串的时候，两者返回的没有区别，但是测试’htttps://xxdfd.163.123.com’ 这字符串的时候返回的不一样，一个是在返回的数组中的第三个位置返回undefined，一个直接是null。因为正则表达式中如果有<code>？</code> 就表示，有也可以，没有也可以。所以上面的例子中字符串中有没有<code>：</code> 都可以匹配成功。如果没有<code>？</code> 则表示字符串中一定要有<code>：</code> 否则就匹配失败。</p>\n<p>上面栗子的正则表达式的目的是提取一个网站的主域名。明眼人一看就知道，这个正则不能达到目的，因为，很多的网站的端口号是默认的，并没有显示出来，像这样’htttps://xxdfd.163.123.com/abc’ ，测试结果如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>果然无法匹配。怎么修改？其实我们已经大致有方向了。</p>\n<p>既然是通常的网站，我们可以匹配<code>：</code> 后面是数字，数字后面是<code>/</code> ,斜杠后面是任意字符</p>\n<p>大致的样子就是下面这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHostNew = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:\\d+)?(\\/.+)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHostNew.exec(<span class=\"string\">'https://xxdfd.163.123.com/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com/abc\", \"123.com\", undefined, \"/abc\"]</span></span><br><span class=\"line\">-------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHostNew.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080/abc\", \"123.com\", \":8080\", \"/abc\"]</span></span><br></pre></td></tr></table></figure>\n<p>修改的就是加上了匹配冒号后的一个或者多个数字，匹配/后面的任意字符。</p>\n<p>上面的例子还没有说完，为什么<code>(\\w+\\.\\w+)</code> 中就可以匹配二级域名？</p>\n<p>我们引入另一个有关问号的关键概念：<strong>非贪婪</strong> 和<strong>贪婪模式</strong>。</p>\n<h4 id=\"用法2\"><a href=\"#用法2\" class=\"headerlink\" title=\"?用法2:\"></a>?用法2:</h4><h4 id=\"如果紧跟在任何量词-、-、-或-的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\"><a href=\"#如果紧跟在任何量词-、-、-或-的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\" class=\"headerlink\" title=\"如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\"></a>如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>的（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。</h4><p>再看例子<code>/^.+\\.(\\w+\\.\\w+)(:.*)$/</code> 中前面的部分<code>.+\\.</code> ，</p>\n<p><code>.</code> 表示匹配除<code>\\r</code>，<code>\\n</code>之外的任何单个字符，</p>\n<p><code>+</code> 可以理解为量词，表示匹配前面一个表达式1次或者多次，</p>\n<p><code>\\.</code> 匹配点号。</p>\n<p>连起来的意思是，匹配任意字符直到点号，那么’htttps://xxdfd.163.123.com/abc’ 中，匹配的应该是’<a href=\"https://xxdfdf.&#39;。\" target=\"_blank\" rel=\"noopener\">https://xxdfdf.&#39;。</a></p>\n<p>再看后面<code>(\\w+\\.\\w+)</code> ，</p>\n<p><code>\\w</code>匹配一个单字字符（字母、数字或者下划线）,</p>\n<p><code>+</code> 量词，表示匹配前面一个表达式1次或者多次,</p>\n<p><code>\\.</code> 匹配点号，</p>\n<p><code>\\w+</code> 匹配一个单字字符（字母、数字或者下划线)1次或者多次，</p>\n<p><code>(\\w+\\.\\w+)</code> 连起来就是匹配xxxx.xxxxx这样的字符串。</p>\n<p>根据上面的分析，<code>(\\w+\\.\\w+)</code> 匹配到的应该是<code>163.123</code> 才对，可是结果却是<code>123.com</code> </p>\n<p>这是为何？原来忽略了<strong>非贪婪</strong> 和<strong>贪婪模式</strong> 。</p>\n<p><code>.+\\.</code> 其中有个量词<code>+</code> ,这个加号后面没有跟随一个<code>?</code> 则说明处于<strong>贪婪模式</strong> 。这个模式下可以匹配尽可能多的字符。怎么理解呢？</p>\n<p><code>.+\\.</code> 意思是匹配任意字符直到<code>.</code> ,在非贪婪模式下可以匹配到’htttps://xxdfd.163.123.’ ，因为点号前面的都可以看成是任意字符，但是，紧接着后面的<code>(\\w+\\.\\w+)</code>,需要匹配xxxx.xxxxx，且（）的优先级比较高，所以，优先匹配了’123.com’，最终，<code>.+\\.</code> 就匹配了’htttps://xxdfd.163’ 。</p>\n<p>为了证实这个说法，我们可以使用非贪婪模式验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'https://xxdfd.163.123.com:8080/dfdf'</span>.match(<span class=\"regexp\">/^.+?\\.(\\w+\\.\\w+).+$/</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080/dfdf\", \"163.123\"]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，结果就变成”163.123”。</p>\n<h3 id=\"（？：pattern）\"><a href=\"#（？：pattern）\" class=\"headerlink\" title=\"（？：pattern）\"></a>（？：pattern）</h3><p>前面的正则表达式中返回的端口号前面有个冒号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组第三个元素值是’：8080‘，如果我们不想要其中的’：‘怎么做呢？</p>\n<p>下面隆重推出<code>？</code> 和其他搭配使用的第一种，和冒号搭配。</p>\n<p>查阅网站，得到如下解说<code>（？：pattern）</code> ：匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(aaa)(?:b)(ccc)$/.exec(<span class=\"string\">'aaabccc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaabccc\", \"aaa\", \"ccc\"]</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(aaa)(b)(ccc)$/.exec(<span class=\"string\">'aaabccc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// [\"aaabccc\", \"aaa\", \"b\", \"ccc\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面两个唯一不同的地方就是b是被（？：pattern）这样的表达式包围的，再看看之前的解说，匹配pattern但不获取匹配的子字符串，这里就是匹配字母b，但是不会作为结果返回。</p>\n<p>所以<code>/^.+\\.(\\w+\\.\\w+)(:.*)$/</code> 这个正则表达式如果想要匹配到冒号，但是不输出，可以使用（？：pattern）的语法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^.+\\.(\\w+\\.\\w+)(?::(.*))$/.exec(<span class=\"string\">'https://xxxxxxx.163.126.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxxxxxx.163.126.com:8080\", \"126.com\", \"8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>知道以上的几个知识点，已经可以解答这个文章最终的正则表达式了。但是为了我以后能更好的理解正则表达式，大神还给我补充了以下知识点</p>\n<h3 id=\"x-y\"><a href=\"#x-y\" class=\"headerlink\" title=\"x(?=y)\"></a>x(?=y)</h3><p>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。</p>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?=Sprat)/.exec(<span class=\"string\">'JackSprat'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"Jack\"]</span></span><br><span class=\"line\">---------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">/Jack(?=Sprat)/.exec(<span class=\"string\">'JackSpraa'</span>)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<p>还有一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?=bb)bbc/.exec(<span class=\"string\">'aaabbc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaabbc\"]</span></span><br><span class=\"line\">-----------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">/aaa(?=bb)c/.exec(<span class=\"string\">'aaabbc'</span>)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>这个例子可以看出，匹配aaa，后面必须是bb，但是(?=bb)后面的表达式却是从aaa后面开始匹配，并不是从bb后开始。使用的时候应该注意。</p>\n<h3 id=\"x-y-1\"><a href=\"#x-y-1\" class=\"headerlink\" title=\"x(?!y)\"></a>x(?!y)</h3><p>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。也就是非的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?!bb)/.exec(<span class=\"string\">'aaab'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaa\"]</span></span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">/aaa(?!bb)/.exec(<span class=\"string\">'aaabb'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>同样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?!bb)c/.exec(<span class=\"string\">'aaac'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaac\"]</span></span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">/aaa(?!bb)c/.exec(<span class=\"string\">'aaam'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>匹配aaa，后面不能是bb，但是(?！bb)后面的表达式却是从aaa后面开始匹配。使用时候应该注意。</p>\n<h2 id=\"解惑\"><a href=\"#解惑\" class=\"headerlink\" title=\"解惑\"></a>解惑</h2><p>最后我们来解读下文章开头的正则表达式</p>\n<p><code>/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</code></p>\n<p>我们先按照小括号一部分一部分的拆开：</p>\n<ol>\n<li><p><code>(?:  ([A-Za-z]+):)?</code></p>\n<p><code>[a-zA-Z]</code> 英文字母，</p>\n<p><code>+</code> 量词，匹配前面表达式1次或者多次，</p>\n<p><code>：</code> 匹配冒号</p>\n<p>连起来就是，匹配’abc:’</p>\n</li>\n<li><p><code>(\\/{0,3})</code></p>\n<p><code>\\/</code> 匹配’/‘</p>\n<p><code>{0,3}</code> 量词，匹配前面表达式0到3次，</p>\n<p>连起来就是，匹配’///‘</p>\n</li>\n<li><p><code>([0-9.\\-A-Za-z]+)</code> </p>\n<p><code>0-9</code> 匹配数字</p>\n<p><code>.</code> 中括号里面的点表示点号本身‘.’</p>\n<p><code>\\-</code> 匹配短横线‘-’</p>\n<p><code>A-Za-z</code> 字母</p>\n<p><code>+</code> 匹配一次或多次，后面没有‘？’，所以使用贪婪模式，尽量匹配多的字符串。</p>\n<p>连起来就是，匹配字母或者数字’.’或者‘-’，匹配‘abc0123.dfdfdf’</p>\n</li>\n<li><p><code>(?:  :(\\d+))?</code> </p>\n<p><code>:</code> 匹配冒号</p>\n<p><code>(\\d+)</code> 匹配数字，尽可能多的匹配</p>\n<p><code>(?:  :）</code> 匹配冒号，但是冒号不作为结果返回</p>\n<p>连起来就是，匹配‘:8080’这样的字符串，然后返回的只有‘8080’。</p>\n</li>\n<li><p><code>(?:  \\/([^?#]*))?</code></p>\n<p><code>\\/</code> 匹配‘/’</p>\n<p><code>[^?#]</code> 匹配所有字符除了‘？’或者‘#’</p>\n<p><code>*</code> 量词，匹配前一个表达式0次或多次</p>\n<p><code>(?:  \\/)</code> 匹配‘/’,但不作为结果输出</p>\n<p>连起来就是，匹配斜杠后面的任意字符直到遇到’？’或者’#’，也就是’/aaaa’,返回’aaaa’。</p>\n</li>\n<li><p><code>(?:   \\?([^#]*))?</code></p>\n<p><code>\\?</code> 匹配问号’？‘</p>\n<p><code>[^#]</code> 匹配所有字符除了‘#’</p>\n<p><code>*</code> 量词，匹配前一个表达式0次或多次</p>\n<p><code>(?:  \\?)</code> 匹配‘？’,但不作为结果输出</p>\n<p>连起来就是，匹配问号后面的任意字符直到遇到‘#’，也就是’?c=4’,返回’c=4‘。</p>\n</li>\n<li><p><code>(?:  #(.*))?</code></p>\n<p><code>#</code> 匹配’#‘</p>\n<p><code>.</code> 匹配除换行符 \\n 之外的任何单字符</p>\n<p><code>*</code> 量词，匹配前面的子表达式零次或多次，默认匹配多次</p>\n<p><code>(?:   #)</code> 匹配’#‘号但是不作为返回值</p>\n<p>连起来就是，匹配#号后面任意字符，也就是，’#bbb‘，返回’bbb‘</p>\n</li>\n</ol>\n<p>综上，整个表达式就是匹配<strong>‘htttps://domain.com:1000/ac/asdasdf?query=xx#dasf’</strong> 这样的字符串，并且返回字符串的各个部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</span><br><span class=\"line\">.exec(<span class=\"string\">'https://domain.com:1000/ac/asdasdf?query=xx#dasf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://domain.com:1000/ac/asdasdf?query=xx#dasf\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// , \"https\", \"//\", \"domain.com\", \"1000\", \"ac/asdasdf\", \"query=xx\", \"dasf\"]</span></span><br><span class=\"line\">https:<span class=\"comment\">//domain.com:1000/ac/asdasdf?query=xx#dasf</span></span><br></pre></td></tr></table></figure>\n<p>看到这里，我想已经能看懂大部分的正则表达式了。还有什么看不懂的可以自己查阅资料来学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"理解正则表达式\"><a href=\"#理解正则表达式\" class=\"headerlink\" title=\"理解正则表达式\"></a>理解正则表达式</h1><blockquote>\n<p>写在前面：正则表达式对于前端开发来说不陌生，虽然使用的频率不是很高，但也难免遇到。可是每次看着网上的解释，我都很头痛。知道项目组中有大神，我决定向大神取经，带我入门。这次的目标就是读懂下面一个表达式：<code>/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</code>。这个表达式是从网上找来的。希望通过这次的学习，可以读懂。</p>\n</blockquote>\n<h2 id=\"正则表达式是什么\"><a href=\"#正则表达式是什么\" class=\"headerlink\" title=\"正则表达式是什么\"></a>正则表达式是什么</h2><p>描述了一种字符串匹配的模式。</p>\n<p>这样听起来非常抽象，我的理解是，一系列的规则，可以判断字符串是否符合规则。</p>\n<p>常见正则表达式如下：</p>\n<ul>\n<li><code>/^(13|14|15|17|18)\\d{9}$/</code>  匹配手机号</li>\n<li><code>/^([\\w\\.-]+)@[\\w][\\w\\.-]*[\\w]\\.([a-zA-Z]{2,6})$/</code>  匹配邮箱</li>\n<li><code>/^[0-9]{6}$/</code>  匹配短信验证码</li>\n</ul>\n<p>用最简单的一个来举例<code>/^[0-9]{6}$/</code>，看下这个是怎么组成的</p>\n<p><img src=\"/2018/06/12/理解正则表达式/reg.png\" alt=\"理解正则表达式图1\"></p>\n<p>可以看到，一般的的这则表达式大致由三个部分组成，中括号包起来的字符集，花括号包起来的限定符，以及一些表示特定意思的特殊字符。</p>\n<p><strong>字符集</strong>:表示匹配的字符的集合，上面的例子表示，0,1,2,3,4,5,6,7,8,9</p>\n<p><strong>限定符</strong>：表示对前面的字符集进行某种限定，上面的例子，表示只能是6个字符</p>\n<p><strong>特殊字符</strong>:<strong>^</strong>表示匹配输入字符串的开始位置</p>\n<p><strong>特殊字符</strong>:<strong>$</strong>表示匹配输入字符串的结束位置</p>\n<p>所以所有的连接起来的意思是只能是0-9中的6个数字组成的字符串。如094567,547845，这种就是符合规则的，dfd456这种就不符合规格。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>看了上面的例子，感觉好像懂了。然而回头看看这篇文章的目标</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.-A-Za-z]+)(?::(\\d+))?(?:\\/(?#))?(?:\\?(#))?(?:#(.*))?$/</span><br></pre></td></tr></table></figure>\n<p>是不是感觉一脸懵逼，百脸懵逼，我是谁？我在哪里？······</p>\n<p>接下来，为了能解说这个正则表达式，我们再来学习一些符号。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"()\"></a>()</h3><p>查阅网站得到如下解说：<code>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</code></p>\n<p>看了又是一脸懵逼，什么意思？</p>\n<p>举个栗子：一个匹配网站二级域名的正则表达式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\",\"123.com\",\":8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>经过观察，这个正则表达式与第一个例子表达式有个很重要的区别，就是有（）。看到上面的结果，可以看出exec返回一个数组，数组的第二值就是我们想要的域名。为什么是第二个呢？</p>\n<p>有的文章解释说：括号被称为 捕获括号。我们把括号去掉，得到如下表达式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.\\w+\\.\\w+:.*$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果如上，没有返回域名和端口号，而加上了两个小括号，就会得到3个结果。</p>\n<p>我们来尝试添加一个（）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+):.*$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\",\"123.com\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果如我所想，返回了两个值。这样我们再看<code>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</code></p>\n<p>这个解释好像能明白一些。如果出现括号，则认为是一个子表达式，如果字符串中有满足子表达式的，将这些字符串保存起来，最后可以以数组的形式返回。如果括号中的子表达式没有被匹配到，就返回undefined。</p>\n<p>也就是说有几个（）就会有几个结果返回。</p>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"?\"></a>?</h3><p>说完（），就来说重头戏问号。</p>\n<h4 id=\"用法1\"><a href=\"#用法1\" class=\"headerlink\" title=\"?用法1:\"></a>?用法1:</h4><h4 id=\"匹配前面一个表达式0次或者1次。等价于-0-1\"><a href=\"#匹配前面一个表达式0次或者1次。等价于-0-1\" class=\"headerlink\" title=\"匹配前面一个表达式0次或者1次。等价于 {0,1}\"></a>匹配前面一个表达式0次或者1次。等价于 {0,1}</h4><p>查阅网站，解说如下：匹配前面一个表达式0次或者1次。等价于 {0,1}。</p>\n<p>还是这个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br></pre></td></tr></table></figure>\n<p>后半段<code>(:.*)?</code>括号后面有个问号。</p>\n<p><code>：</code>表示匹配‘：’，</p>\n<p><code>.</code>号表示匹配除“<code>\\r</code>”“<code>\\n</code>”之外的任何单个字符，</p>\n<p><code>*</code>表示匹配前面的子表达式零次或多次。</p>\n<p>括号里面连起来就是，匹配：后面的所有字符零次或多次。</p>\n<p>然后<code>？</code>表示匹配前面一个表达式0次或者1次，换一种说法就是，匹配前面一个表达式有或者没有。</p>\n<p>有问号没问号什么区别？看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost2 = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost2.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)？$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost2 = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost2.exec(<span class=\"string\">'https://xxdfd.163.123.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)？$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com\"，\"123.com\"，undefined]</span></span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出来，在测试’htttps://xxdfd.163.123.com:8080’ 这个字符串的时候，两者返回的没有区别，但是测试’htttps://xxdfd.163.123.com’ 这字符串的时候返回的不一样，一个是在返回的数组中的第三个位置返回undefined，一个直接是null。因为正则表达式中如果有<code>？</code> 就表示，有也可以，没有也可以。所以上面的例子中字符串中有没有<code>：</code> 都可以匹配成功。如果没有<code>？</code> 则表示字符串中一定要有<code>：</code> 否则就匹配失败。</p>\n<p>上面栗子的正则表达式的目的是提取一个网站的主域名。明眼人一看就知道，这个正则不能达到目的，因为，很多的网站的端口号是默认的，并没有显示出来，像这样’htttps://xxdfd.163.123.com/abc’ ，测试结果如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>果然无法匹配。怎么修改？其实我们已经大致有方向了。</p>\n<p>既然是通常的网站，我们可以匹配<code>：</code> 后面是数字，数字后面是<code>/</code> ,斜杠后面是任意字符</p>\n<p>大致的样子就是下面这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHostNew = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:\\d+)?(\\/.+)?$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHostNew.exec(<span class=\"string\">'https://xxdfd.163.123.com/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com/abc\", \"123.com\", undefined, \"/abc\"]</span></span><br><span class=\"line\">-------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHostNew.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080/abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080/abc\", \"123.com\", \":8080\", \"/abc\"]</span></span><br></pre></td></tr></table></figure>\n<p>修改的就是加上了匹配冒号后的一个或者多个数字，匹配/后面的任意字符。</p>\n<p>上面的例子还没有说完，为什么<code>(\\w+\\.\\w+)</code> 中就可以匹配二级域名？</p>\n<p>我们引入另一个有关问号的关键概念：<strong>非贪婪</strong> 和<strong>贪婪模式</strong>。</p>\n<h4 id=\"用法2\"><a href=\"#用法2\" class=\"headerlink\" title=\"?用法2:\"></a>?用法2:</h4><h4 id=\"如果紧跟在任何量词-、-、-或-的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\"><a href=\"#如果紧跟在任何量词-、-、-或-的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\" class=\"headerlink\" title=\"如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。\"></a>如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>的（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。</h4><p>再看例子<code>/^.+\\.(\\w+\\.\\w+)(:.*)$/</code> 中前面的部分<code>.+\\.</code> ，</p>\n<p><code>.</code> 表示匹配除<code>\\r</code>，<code>\\n</code>之外的任何单个字符，</p>\n<p><code>+</code> 可以理解为量词，表示匹配前面一个表达式1次或者多次，</p>\n<p><code>\\.</code> 匹配点号。</p>\n<p>连起来的意思是，匹配任意字符直到点号，那么’htttps://xxdfd.163.123.com/abc’ 中，匹配的应该是’<a href=\"https://xxdfdf.&#39;。\" target=\"_blank\" rel=\"noopener\">https://xxdfdf.&#39;。</a></p>\n<p>再看后面<code>(\\w+\\.\\w+)</code> ，</p>\n<p><code>\\w</code>匹配一个单字字符（字母、数字或者下划线）,</p>\n<p><code>+</code> 量词，表示匹配前面一个表达式1次或者多次,</p>\n<p><code>\\.</code> 匹配点号，</p>\n<p><code>\\w+</code> 匹配一个单字字符（字母、数字或者下划线)1次或者多次，</p>\n<p><code>(\\w+\\.\\w+)</code> 连起来就是匹配xxxx.xxxxx这样的字符串。</p>\n<p>根据上面的分析，<code>(\\w+\\.\\w+)</code> 匹配到的应该是<code>163.123</code> 才对，可是结果却是<code>123.com</code> </p>\n<p>这是为何？原来忽略了<strong>非贪婪</strong> 和<strong>贪婪模式</strong> 。</p>\n<p><code>.+\\.</code> 其中有个量词<code>+</code> ,这个加号后面没有跟随一个<code>?</code> 则说明处于<strong>贪婪模式</strong> 。这个模式下可以匹配尽可能多的字符。怎么理解呢？</p>\n<p><code>.+\\.</code> 意思是匹配任意字符直到<code>.</code> ,在非贪婪模式下可以匹配到’htttps://xxdfd.163.123.’ ，因为点号前面的都可以看成是任意字符，但是，紧接着后面的<code>(\\w+\\.\\w+)</code>,需要匹配xxxx.xxxxx，且（）的优先级比较高，所以，优先匹配了’123.com’，最终，<code>.+\\.</code> 就匹配了’htttps://xxdfd.163’ 。</p>\n<p>为了证实这个说法，我们可以使用非贪婪模式验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'https://xxdfd.163.123.com:8080/dfdf'</span>.match(<span class=\"regexp\">/^.+?\\.(\\w+\\.\\w+).+$/</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080/dfdf\", \"163.123\"]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，结果就变成”163.123”。</p>\n<h3 id=\"（？：pattern）\"><a href=\"#（？：pattern）\" class=\"headerlink\" title=\"（？：pattern）\"></a>（？：pattern）</h3><p>前面的正则表达式中返回的端口号前面有个冒号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regParentHost = <span class=\"regexp\">/^.+\\.(\\w+\\.\\w+)(:.*)$/</span></span><br><span class=\"line\"></span><br><span class=\"line\">regParentHost.exec(<span class=\"string\">'https://xxdfd.163.123.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxdfd.163.123.com:8080\"，\"123.com\"，\":8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组第三个元素值是’：8080‘，如果我们不想要其中的’：‘怎么做呢？</p>\n<p>下面隆重推出<code>？</code> 和其他搭配使用的第一种，和冒号搭配。</p>\n<p>查阅网站，得到如下解说<code>（？：pattern）</code> ：匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(aaa)(?:b)(ccc)$/.exec(<span class=\"string\">'aaabccc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaabccc\", \"aaa\", \"ccc\"]</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(aaa)(b)(ccc)$/.exec(<span class=\"string\">'aaabccc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// [\"aaabccc\", \"aaa\", \"b\", \"ccc\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面两个唯一不同的地方就是b是被（？：pattern）这样的表达式包围的，再看看之前的解说，匹配pattern但不获取匹配的子字符串，这里就是匹配字母b，但是不会作为结果返回。</p>\n<p>所以<code>/^.+\\.(\\w+\\.\\w+)(:.*)$/</code> 这个正则表达式如果想要匹配到冒号，但是不输出，可以使用（？：pattern）的语法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^.+\\.(\\w+\\.\\w+)(?::(.*))$/.exec(<span class=\"string\">'https://xxxxxxx.163.126.com:8080'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://xxxxxxx.163.126.com:8080\", \"126.com\", \"8080\"]</span></span><br></pre></td></tr></table></figure>\n<p>知道以上的几个知识点，已经可以解答这个文章最终的正则表达式了。但是为了我以后能更好的理解正则表达式，大神还给我补充了以下知识点</p>\n<h3 id=\"x-y\"><a href=\"#x-y\" class=\"headerlink\" title=\"x(?=y)\"></a>x(?=y)</h3><p>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。</p>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Jack(?=Sprat)/.exec(<span class=\"string\">'JackSprat'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"Jack\"]</span></span><br><span class=\"line\">---------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">/Jack(?=Sprat)/.exec(<span class=\"string\">'JackSpraa'</span>)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<p>还有一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?=bb)bbc/.exec(<span class=\"string\">'aaabbc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaabbc\"]</span></span><br><span class=\"line\">-----------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">/aaa(?=bb)c/.exec(<span class=\"string\">'aaabbc'</span>)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>这个例子可以看出，匹配aaa，后面必须是bb，但是(?=bb)后面的表达式却是从aaa后面开始匹配，并不是从bb后开始。使用的时候应该注意。</p>\n<h3 id=\"x-y-1\"><a href=\"#x-y-1\" class=\"headerlink\" title=\"x(?!y)\"></a>x(?!y)</h3><p>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。也就是非的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?!bb)/.exec(<span class=\"string\">'aaab'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaa\"]</span></span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">/aaa(?!bb)/.exec(<span class=\"string\">'aaabb'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>同样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/aaa(?!bb)c/.exec(<span class=\"string\">'aaac'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"aaac\"]</span></span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">/aaa(?!bb)c/.exec(<span class=\"string\">'aaam'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>匹配aaa，后面不能是bb，但是(?！bb)后面的表达式却是从aaa后面开始匹配。使用时候应该注意。</p>\n<h2 id=\"解惑\"><a href=\"#解惑\" class=\"headerlink\" title=\"解惑\"></a>解惑</h2><p>最后我们来解读下文章开头的正则表达式</p>\n<p><code>/^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</code></p>\n<p>我们先按照小括号一部分一部分的拆开：</p>\n<ol>\n<li><p><code>(?:  ([A-Za-z]+):)?</code></p>\n<p><code>[a-zA-Z]</code> 英文字母，</p>\n<p><code>+</code> 量词，匹配前面表达式1次或者多次，</p>\n<p><code>：</code> 匹配冒号</p>\n<p>连起来就是，匹配’abc:’</p>\n</li>\n<li><p><code>(\\/{0,3})</code></p>\n<p><code>\\/</code> 匹配’/‘</p>\n<p><code>{0,3}</code> 量词，匹配前面表达式0到3次，</p>\n<p>连起来就是，匹配’///‘</p>\n</li>\n<li><p><code>([0-9.\\-A-Za-z]+)</code> </p>\n<p><code>0-9</code> 匹配数字</p>\n<p><code>.</code> 中括号里面的点表示点号本身‘.’</p>\n<p><code>\\-</code> 匹配短横线‘-’</p>\n<p><code>A-Za-z</code> 字母</p>\n<p><code>+</code> 匹配一次或多次，后面没有‘？’，所以使用贪婪模式，尽量匹配多的字符串。</p>\n<p>连起来就是，匹配字母或者数字’.’或者‘-’，匹配‘abc0123.dfdfdf’</p>\n</li>\n<li><p><code>(?:  :(\\d+))?</code> </p>\n<p><code>:</code> 匹配冒号</p>\n<p><code>(\\d+)</code> 匹配数字，尽可能多的匹配</p>\n<p><code>(?:  :）</code> 匹配冒号，但是冒号不作为结果返回</p>\n<p>连起来就是，匹配‘:8080’这样的字符串，然后返回的只有‘8080’。</p>\n</li>\n<li><p><code>(?:  \\/([^?#]*))?</code></p>\n<p><code>\\/</code> 匹配‘/’</p>\n<p><code>[^?#]</code> 匹配所有字符除了‘？’或者‘#’</p>\n<p><code>*</code> 量词，匹配前一个表达式0次或多次</p>\n<p><code>(?:  \\/)</code> 匹配‘/’,但不作为结果输出</p>\n<p>连起来就是，匹配斜杠后面的任意字符直到遇到’？’或者’#’，也就是’/aaaa’,返回’aaaa’。</p>\n</li>\n<li><p><code>(?:   \\?([^#]*))?</code></p>\n<p><code>\\?</code> 匹配问号’？‘</p>\n<p><code>[^#]</code> 匹配所有字符除了‘#’</p>\n<p><code>*</code> 量词，匹配前一个表达式0次或多次</p>\n<p><code>(?:  \\?)</code> 匹配‘？’,但不作为结果输出</p>\n<p>连起来就是，匹配问号后面的任意字符直到遇到‘#’，也就是’?c=4’,返回’c=4‘。</p>\n</li>\n<li><p><code>(?:  #(.*))?</code></p>\n<p><code>#</code> 匹配’#‘</p>\n<p><code>.</code> 匹配除换行符 \\n 之外的任何单字符</p>\n<p><code>*</code> 量词，匹配前面的子表达式零次或多次，默认匹配多次</p>\n<p><code>(?:   #)</code> 匹配’#‘号但是不作为返回值</p>\n<p>连起来就是，匹配#号后面任意字符，也就是，’#bbb‘，返回’bbb‘</p>\n</li>\n</ol>\n<p>综上，整个表达式就是匹配<strong>‘htttps://domain.com:1000/ac/asdasdf?query=xx#dasf’</strong> 这样的字符串，并且返回字符串的各个部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/</span><br><span class=\"line\">.exec(<span class=\"string\">'https://domain.com:1000/ac/asdasdf?query=xx#dasf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"https://domain.com:1000/ac/asdasdf?query=xx#dasf\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// , \"https\", \"//\", \"domain.com\", \"1000\", \"ac/asdasdf\", \"query=xx\", \"dasf\"]</span></span><br><span class=\"line\">https:<span class=\"comment\">//domain.com:1000/ac/asdasdf?query=xx#dasf</span></span><br></pre></td></tr></table></figure>\n<p>看到这里，我想已经能看懂大部分的正则表达式了。还有什么看不懂的可以自己查阅资料来学习。</p>\n"},{"title":"单例模式理解和应用","date":"2018-07-19T07:48:36.000Z","_content":"\n# 单例模式理解和应用\n\n> 写在前面：前段时间在看Rx js时候看到观察者模式，联想到单例模式，然后自己学习了下。不看不知道，原来自己在平时写代码的过程中用的最多的就是单例模式。在项目中也有很多应用。这里做下总结。\n\n\n\n### 什么是单例模式?\n\n什么是单例模式?顾名思义，就是只有一个实例。即使多次实例化一个类，也只返回第一次的实例。这样说可能比较抽象，看看实际中最简单的单例模式：\n\n```js\nlet hmacsha256 = {\n  name: '哈希加密',\n  encrypt: function() {},\n  decrypt: function() {}\n}\nhmacsha256.name // '哈希加密'\n```\n\n上面字面量形式的创建对象，这个对象hmacsha256有两个方法一个变量。可以通过hmacsha256.encrypt()来调用方法。这是我们最常见的单例模式。但是这样写有个特点，就是hmacsha256的所有方法和变量都是公共的，但是如果有一些内部的辅助函数我们不希望暴露出去的话，这样的单例就无法满足我们的需求。\n\n\n\n### 有私有变量的单例模式\n\n如果像上面说的那样，不想要把所有的方法和变量都暴露出去，以免有的方法被修改，那我们可以只返回自己想要暴露的方法和变量，就像下面这样：\n\n```js\nvar hmacsha256 = function () {\n\n    /* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n\n    /* 公有变量和方法（可以访问私有变量和方法） */\n    return {\n        getValue: function () {\n            showPrivate();\n        },\n        encrypt: function() {},\n      \tdecrypt: function() {}\n    };\n};\n\nvar single = hmacsha256();\nsingle.getValue();  // '哈希加密'\n```\n\n这样我们对外暴露了3个方法，而name值不在能通过`hmacsha256.name` 拿到，所以name已经变成了类的私有变量，只有通过`single.getValue()` 才能拿到，如果，不提供修改这个值的方法，外部就无法修改这个变量。这其实这是一个闭包的典型应用。\n\n通过这个修改以后发我们发现，这个类在应用这个js的时候初始化一次，但是如果这个js里面的方法一直没有被用到的话，那就等于浪费了一些开销，因为一直没有用到。于是我们希望在引入的时候也不实例化，而是在真正使用的时候在实例化，这就引入了一个`懒性单例的概念` \n\n\n\n### 懒性单例\n\n怎么样能做到引入的时候不实例化呢？我们借助自执行函数来实现。\n\n```js\n/* 懒性单例写法一 */\nvar hmacsha256 = (function () {\n    var instance;\n   \t/* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n    function init(option) {\n        /*这里定义单例代码*/\n        return {\n          getValue: function () {\n              showPrivate();\n          },\n          encrypt: function() {},\n          decrypt: function() {}\n        };\n    }\n\n    return {\n        getInstance: function (option) {\n            if (!instance) {\n                instance = init(option);\n            }\n            return instance;\n        }\n    };\n})();\n\n/*调用公有的方法来获取实例:*/\nhmacsha256.getInstance(); \n```\n\n自执行函数，我的理解是一种巧妙的方法，使得我们可以将匿名函数以函数表达式的方式进行创建，并返回匿名函数对象的引用。在结尾加上一对括号，可以调用匿名函数对象的引用，让函数立即被执行。\n\n这里需要说明一下，`()` 的作用，`()` 的作用是迫使js解析器在解析的时候**强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行** 。也就是说`(function () {})` 这个括号中虽然有function关键字，但是由于有括号，所有解析器并没有把他当做一个function，而是强制把里面的内容转成了一个对象，并返回指向这个对象的指针。\n\n`（）` 在这里的作用与用**Eval把json格式字符串转换为json对象** 时的作用一样，这就是为啥`eval(\"(\" + testJson + \")\");` 一定要多加一个括号的原因。\n\n```js\nalert(eval(\"{}\");  // return undefined\nalert(eval(\"({})\");// return object[Object]\n```\n\n\n\n事实上，上面的代码和下面的写法的效果一样。\n\n```js\n/* 懒性单例写法二 */\nfunction hmacsha256 () {\n    var instance;\n   \t/* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n    function init(option) {\n        /*这里定义单例代码*/\n        return {\n          getValue: function () {\n              showPrivate();\n          },\n          encrypt: function() {},\n          decrypt: function() {}\n        };\n    }\n\n    return {\n        getInstance: function (option) {\n            if (!instance) {\n                instance = init(option);\n            }\n            return instance;\n        }\n    };\n}\n\n/*调用公有的方法来获取实例:*/\nhmacsha256().getInstance(); \n```\n\n但是为什么要使用自执行函数呢？答案就是**隔离作用域** 。第二种写法虽然功能可以实现，但是function hmacsha256这个方法随时候有可能被人改写。第一种写法中，就算你hmacsha256返回上千种方法，里面有再多的私有变量，都不影响其他的作用域。他只管hmacsha256这个变量下的东西，就像有一个命名空间一样。\n\n\n\n### 单例模式解决了什么问题？\n\n单例模式只有一个实例，节约了系统的开销。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。比如，工具类，登录框，导航，这些都是系统中单例模式的绝佳使用场景。除了能解决这种业务场景的问题，隔离作用域和模块的分割也是我们使用的最多的姿势。\n\n```js\nvar hmacsha256 = {\n  encrypt: function () {\n  },\n  decrypt: function () {\n  }\n}\n\nvar getAuthorization = function (token) {\n  return authorization;\n}\n\nexport {\n  hmacsha256,\n  getAuthorization\n}\n```\n\n\n\n### 单例模式在项目实战应用\n\n项目中有个需求是提供一个sdk，初始化以后可以生成一个顶部和右侧的导航栏。这个导航栏真个项目中只有一个，只需要一个实例，这就是典型的单例模式。\n\n```js\n  window.mySDK = (function () {\n    var instance;\n    function initSDK (option) {\n      /* \n      判断是否登录，获取账号信息\n      初始化顶栏和侧边栏\n      调用外部传进来的init方法\n      */\n    }\n    function showSd (option) {\n      /*控制侧边栏展开还是收起*/\n    }\n    function resetSd (option) {\n      /*传入新的filter方法并重置左侧导航*/\n    }\n    function constructor (option) {\n      \n      initSDK(option);\n\n      return {\n        head: option.head,/*初始化顶部的div的id*/\n        side: option.side,/*初始左侧导航栏div的id*/\n        sdHide: option.sdHide,\n        showSd: showSd,\n        resetSd: resetSd,\n        init: function () {\n          typeof(option.init)==='function' ? option.init() : undefined\n        },\n        signOut: function () {\n          typeof(option.signOut)==='function' ? option.signOut() : undefined\n        }\n      }\n    }\n    return {\n      getInstance: function (option) {\n        if (!instance) {\n          instance = constructor(option)\n        }\n        return instance;\n      }\n    }\n  })()\n\n\nvar options = {\n  sdHide: false,\n  resetSd: function () {},\n  init: function () {}\n}\n\nmySDK = window.mySDK.getInstance({\n  head: 'top',\n  side: 'left',\n  resetSd: options.filterSd,\n  sdHide: options.sdHide,\n  init: options.init\n})\n```\n\n这里把实现的具体的内容省去，其实在 initSDK 中做了很多的工作。但这是有关业务的内容，我们需要根据不同的业务员场景自行实现。但运用单例模式，可以保证导航栏只有一个实例。\n\n\n\n其他参考文章：\n\nhttps://zhuanlan.zhihu.com/p/34754447","source":"_posts/单例模式理解和应用.md","raw":"---\ntitle: '单例模式理解和应用'\ndate: 2018-07-19 15:48:36\ntags:\n- 前端\n- js\n- 模式\n---\n\n# 单例模式理解和应用\n\n> 写在前面：前段时间在看Rx js时候看到观察者模式，联想到单例模式，然后自己学习了下。不看不知道，原来自己在平时写代码的过程中用的最多的就是单例模式。在项目中也有很多应用。这里做下总结。\n\n\n\n### 什么是单例模式?\n\n什么是单例模式?顾名思义，就是只有一个实例。即使多次实例化一个类，也只返回第一次的实例。这样说可能比较抽象，看看实际中最简单的单例模式：\n\n```js\nlet hmacsha256 = {\n  name: '哈希加密',\n  encrypt: function() {},\n  decrypt: function() {}\n}\nhmacsha256.name // '哈希加密'\n```\n\n上面字面量形式的创建对象，这个对象hmacsha256有两个方法一个变量。可以通过hmacsha256.encrypt()来调用方法。这是我们最常见的单例模式。但是这样写有个特点，就是hmacsha256的所有方法和变量都是公共的，但是如果有一些内部的辅助函数我们不希望暴露出去的话，这样的单例就无法满足我们的需求。\n\n\n\n### 有私有变量的单例模式\n\n如果像上面说的那样，不想要把所有的方法和变量都暴露出去，以免有的方法被修改，那我们可以只返回自己想要暴露的方法和变量，就像下面这样：\n\n```js\nvar hmacsha256 = function () {\n\n    /* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n\n    /* 公有变量和方法（可以访问私有变量和方法） */\n    return {\n        getValue: function () {\n            showPrivate();\n        },\n        encrypt: function() {},\n      \tdecrypt: function() {}\n    };\n};\n\nvar single = hmacsha256();\nsingle.getValue();  // '哈希加密'\n```\n\n这样我们对外暴露了3个方法，而name值不在能通过`hmacsha256.name` 拿到，所以name已经变成了类的私有变量，只有通过`single.getValue()` 才能拿到，如果，不提供修改这个值的方法，外部就无法修改这个变量。这其实这是一个闭包的典型应用。\n\n通过这个修改以后发我们发现，这个类在应用这个js的时候初始化一次，但是如果这个js里面的方法一直没有被用到的话，那就等于浪费了一些开销，因为一直没有用到。于是我们希望在引入的时候也不实例化，而是在真正使用的时候在实例化，这就引入了一个`懒性单例的概念` \n\n\n\n### 懒性单例\n\n怎么样能做到引入的时候不实例化呢？我们借助自执行函数来实现。\n\n```js\n/* 懒性单例写法一 */\nvar hmacsha256 = (function () {\n    var instance;\n   \t/* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n    function init(option) {\n        /*这里定义单例代码*/\n        return {\n          getValue: function () {\n              showPrivate();\n          },\n          encrypt: function() {},\n          decrypt: function() {}\n        };\n    }\n\n    return {\n        getInstance: function (option) {\n            if (!instance) {\n                instance = init(option);\n            }\n            return instance;\n        }\n    };\n})();\n\n/*调用公有的方法来获取实例:*/\nhmacsha256.getInstance(); \n```\n\n自执行函数，我的理解是一种巧妙的方法，使得我们可以将匿名函数以函数表达式的方式进行创建，并返回匿名函数对象的引用。在结尾加上一对括号，可以调用匿名函数对象的引用，让函数立即被执行。\n\n这里需要说明一下，`()` 的作用，`()` 的作用是迫使js解析器在解析的时候**强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行** 。也就是说`(function () {})` 这个括号中虽然有function关键字，但是由于有括号，所有解析器并没有把他当做一个function，而是强制把里面的内容转成了一个对象，并返回指向这个对象的指针。\n\n`（）` 在这里的作用与用**Eval把json格式字符串转换为json对象** 时的作用一样，这就是为啥`eval(\"(\" + testJson + \")\");` 一定要多加一个括号的原因。\n\n```js\nalert(eval(\"{}\");  // return undefined\nalert(eval(\"({})\");// return object[Object]\n```\n\n\n\n事实上，上面的代码和下面的写法的效果一样。\n\n```js\n/* 懒性单例写法二 */\nfunction hmacsha256 () {\n    var instance;\n   \t/* 私有变量和方法 */\n    var name = '哈希加密';\n    function showPrivate() {\n        console.log(name);\n    }\n    function init(option) {\n        /*这里定义单例代码*/\n        return {\n          getValue: function () {\n              showPrivate();\n          },\n          encrypt: function() {},\n          decrypt: function() {}\n        };\n    }\n\n    return {\n        getInstance: function (option) {\n            if (!instance) {\n                instance = init(option);\n            }\n            return instance;\n        }\n    };\n}\n\n/*调用公有的方法来获取实例:*/\nhmacsha256().getInstance(); \n```\n\n但是为什么要使用自执行函数呢？答案就是**隔离作用域** 。第二种写法虽然功能可以实现，但是function hmacsha256这个方法随时候有可能被人改写。第一种写法中，就算你hmacsha256返回上千种方法，里面有再多的私有变量，都不影响其他的作用域。他只管hmacsha256这个变量下的东西，就像有一个命名空间一样。\n\n\n\n### 单例模式解决了什么问题？\n\n单例模式只有一个实例，节约了系统的开销。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。比如，工具类，登录框，导航，这些都是系统中单例模式的绝佳使用场景。除了能解决这种业务场景的问题，隔离作用域和模块的分割也是我们使用的最多的姿势。\n\n```js\nvar hmacsha256 = {\n  encrypt: function () {\n  },\n  decrypt: function () {\n  }\n}\n\nvar getAuthorization = function (token) {\n  return authorization;\n}\n\nexport {\n  hmacsha256,\n  getAuthorization\n}\n```\n\n\n\n### 单例模式在项目实战应用\n\n项目中有个需求是提供一个sdk，初始化以后可以生成一个顶部和右侧的导航栏。这个导航栏真个项目中只有一个，只需要一个实例，这就是典型的单例模式。\n\n```js\n  window.mySDK = (function () {\n    var instance;\n    function initSDK (option) {\n      /* \n      判断是否登录，获取账号信息\n      初始化顶栏和侧边栏\n      调用外部传进来的init方法\n      */\n    }\n    function showSd (option) {\n      /*控制侧边栏展开还是收起*/\n    }\n    function resetSd (option) {\n      /*传入新的filter方法并重置左侧导航*/\n    }\n    function constructor (option) {\n      \n      initSDK(option);\n\n      return {\n        head: option.head,/*初始化顶部的div的id*/\n        side: option.side,/*初始左侧导航栏div的id*/\n        sdHide: option.sdHide,\n        showSd: showSd,\n        resetSd: resetSd,\n        init: function () {\n          typeof(option.init)==='function' ? option.init() : undefined\n        },\n        signOut: function () {\n          typeof(option.signOut)==='function' ? option.signOut() : undefined\n        }\n      }\n    }\n    return {\n      getInstance: function (option) {\n        if (!instance) {\n          instance = constructor(option)\n        }\n        return instance;\n      }\n    }\n  })()\n\n\nvar options = {\n  sdHide: false,\n  resetSd: function () {},\n  init: function () {}\n}\n\nmySDK = window.mySDK.getInstance({\n  head: 'top',\n  side: 'left',\n  resetSd: options.filterSd,\n  sdHide: options.sdHide,\n  init: options.init\n})\n```\n\n这里把实现的具体的内容省去，其实在 initSDK 中做了很多的工作。但这是有关业务的内容，我们需要根据不同的业务员场景自行实现。但运用单例模式，可以保证导航栏只有一个实例。\n\n\n\n其他参考文章：\n\nhttps://zhuanlan.zhihu.com/p/34754447","slug":"单例模式理解和应用","published":1,"updated":"2018-07-19T07:52:27.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzcj7000s5oisallxmoo9","content":"<h1 id=\"单例模式理解和应用\"><a href=\"#单例模式理解和应用\" class=\"headerlink\" title=\"单例模式理解和应用\"></a>单例模式理解和应用</h1><blockquote>\n<p>写在前面：前段时间在看Rx js时候看到观察者模式，联想到单例模式，然后自己学习了下。不看不知道，原来自己在平时写代码的过程中用的最多的就是单例模式。在项目中也有很多应用。这里做下总结。</p>\n</blockquote>\n<h3 id=\"什么是单例模式\"><a href=\"#什么是单例模式\" class=\"headerlink\" title=\"什么是单例模式?\"></a>什么是单例模式?</h3><p>什么是单例模式?顾名思义，就是只有一个实例。即使多次实例化一个类，也只返回第一次的实例。这样说可能比较抽象，看看实际中最简单的单例模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hmacsha256 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'哈希加密'</span>,</span><br><span class=\"line\">  encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hmacsha256.name <span class=\"comment\">// '哈希加密'</span></span><br></pre></td></tr></table></figure>\n<p>上面字面量形式的创建对象，这个对象hmacsha256有两个方法一个变量。可以通过hmacsha256.encrypt()来调用方法。这是我们最常见的单例模式。但是这样写有个特点，就是hmacsha256的所有方法和变量都是公共的，但是如果有一些内部的辅助函数我们不希望暴露出去的话，这样的单例就无法满足我们的需求。</p>\n<h3 id=\"有私有变量的单例模式\"><a href=\"#有私有变量的单例模式\" class=\"headerlink\" title=\"有私有变量的单例模式\"></a>有私有变量的单例模式</h3><p>如果像上面说的那样，不想要把所有的方法和变量都暴露出去，以免有的方法被修改，那我们可以只返回自己想要暴露的方法和变量，就像下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 公有变量和方法（可以访问私有变量和方法） */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            showPrivate();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">      \tdecrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> single = hmacsha256();</span><br><span class=\"line\">single.getValue();  <span class=\"comment\">// '哈希加密'</span></span><br></pre></td></tr></table></figure>\n<p>这样我们对外暴露了3个方法，而name值不在能通过<code>hmacsha256.name</code> 拿到，所以name已经变成了类的私有变量，只有通过<code>single.getValue()</code> 才能拿到，如果，不提供修改这个值的方法，外部就无法修改这个变量。这其实这是一个闭包的典型应用。</p>\n<p>通过这个修改以后发我们发现，这个类在应用这个js的时候初始化一次，但是如果这个js里面的方法一直没有被用到的话，那就等于浪费了一些开销，因为一直没有用到。于是我们希望在引入的时候也不实例化，而是在真正使用的时候在实例化，这就引入了一个<code>懒性单例的概念</code> </p>\n<h3 id=\"懒性单例\"><a href=\"#懒性单例\" class=\"headerlink\" title=\"懒性单例\"></a>懒性单例</h3><p>怎么样能做到引入的时候不实例化呢？我们借助自执行函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 懒性单例写法一 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">   \t<span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*这里定义单例代码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">              showPrivate();</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">          decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">                instance = init(option);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*调用公有的方法来获取实例:*/</span></span><br><span class=\"line\">hmacsha256.getInstance();</span><br></pre></td></tr></table></figure>\n<p>自执行函数，我的理解是一种巧妙的方法，使得我们可以将匿名函数以函数表达式的方式进行创建，并返回匿名函数对象的引用。在结尾加上一对括号，可以调用匿名函数对象的引用，让函数立即被执行。</p>\n<p>这里需要说明一下，<code>()</code> 的作用，<code>()</code> 的作用是迫使js解析器在解析的时候<strong>强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行</strong> 。也就是说<code>(function () {})</code> 这个括号中虽然有function关键字，但是由于有括号，所有解析器并没有把他当做一个function，而是强制把里面的内容转成了一个对象，并返回指向这个对象的指针。</p>\n<p><code>（）</code> 在这里的作用与用<strong>Eval把json格式字符串转换为json对象</strong> 时的作用一样，这就是为啥<code>eval(&quot;(&quot; + testJson + &quot;)&quot;);</code> 一定要多加一个括号的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">\"&#123;&#125;\"</span>);  <span class=\"comment\">// return undefined</span></span><br><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">\"(&#123;&#125;)\"</span>);<span class=\"comment\">// return object[Object]</span></span><br></pre></td></tr></table></figure>\n<p>事实上，上面的代码和下面的写法的效果一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 懒性单例写法二 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hmacsha256</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">   \t<span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*这里定义单例代码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">              showPrivate();</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">          decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">                instance = init(option);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*调用公有的方法来获取实例:*/</span></span><br><span class=\"line\">hmacsha256().getInstance();</span><br></pre></td></tr></table></figure>\n<p>但是为什么要使用自执行函数呢？答案就是<strong>隔离作用域</strong> 。第二种写法虽然功能可以实现，但是function hmacsha256这个方法随时候有可能被人改写。第一种写法中，就算你hmacsha256返回上千种方法，里面有再多的私有变量，都不影响其他的作用域。他只管hmacsha256这个变量下的东西，就像有一个命名空间一样。</p>\n<h3 id=\"单例模式解决了什么问题？\"><a href=\"#单例模式解决了什么问题？\" class=\"headerlink\" title=\"单例模式解决了什么问题？\"></a>单例模式解决了什么问题？</h3><p>单例模式只有一个实例，节约了系统的开销。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。比如，工具类，登录框，导航，这些都是系统中单例模式的绝佳使用场景。除了能解决这种业务场景的问题，隔离作用域和模块的分割也是我们使用的最多的姿势。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = &#123;</span><br><span class=\"line\">  encrypt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  decrypt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getAuthorization = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">token</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> authorization;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  hmacsha256,</span><br><span class=\"line\">  getAuthorization</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式在项目实战应用\"><a href=\"#单例模式在项目实战应用\" class=\"headerlink\" title=\"单例模式在项目实战应用\"></a>单例模式在项目实战应用</h3><p>项目中有个需求是提供一个sdk，初始化以后可以生成一个顶部和右侧的导航栏。这个导航栏真个项目中只有一个，只需要一个实例，这就是典型的单例模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"built_in\">window</span>.mySDK = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initSDK</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">      判断是否登录，获取账号信息</span></span><br><span class=\"line\"><span class=\"comment\">      初始化顶栏和侧边栏</span></span><br><span class=\"line\"><span class=\"comment\">      调用外部传进来的init方法</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showSd</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*控制侧边栏展开还是收起*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetSd</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*传入新的filter方法并重置左侧导航*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructor</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      initSDK(option);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        head: option.head,<span class=\"comment\">/*初始化顶部的div的id*/</span></span><br><span class=\"line\">        side: option.side,<span class=\"comment\">/*初始左侧导航栏div的id*/</span></span><br><span class=\"line\">        sdHide: option.sdHide,</span><br><span class=\"line\">        showSd: showSd,</span><br><span class=\"line\">        resetSd: resetSd,</span><br><span class=\"line\">        init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">typeof</span>(option.init)===<span class=\"string\">'function'</span> ? option.init() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        signOut: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">typeof</span>(option.signOut)===<span class=\"string\">'function'</span> ? option.signOut() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">constructor</span>(option)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">  sdHide: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  resetSd: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mySDK = <span class=\"built_in\">window</span>.mySDK.getInstance(&#123;</span><br><span class=\"line\">  head: <span class=\"string\">'top'</span>,</span><br><span class=\"line\">  side: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">  resetSd: options.filterSd,</span><br><span class=\"line\">  sdHide: options.sdHide,</span><br><span class=\"line\">  init: options.init</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里把实现的具体的内容省去，其实在 initSDK 中做了很多的工作。但这是有关业务的内容，我们需要根据不同的业务员场景自行实现。但运用单例模式，可以保证导航栏只有一个实例。</p>\n<p>其他参考文章：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/34754447\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34754447</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单例模式理解和应用\"><a href=\"#单例模式理解和应用\" class=\"headerlink\" title=\"单例模式理解和应用\"></a>单例模式理解和应用</h1><blockquote>\n<p>写在前面：前段时间在看Rx js时候看到观察者模式，联想到单例模式，然后自己学习了下。不看不知道，原来自己在平时写代码的过程中用的最多的就是单例模式。在项目中也有很多应用。这里做下总结。</p>\n</blockquote>\n<h3 id=\"什么是单例模式\"><a href=\"#什么是单例模式\" class=\"headerlink\" title=\"什么是单例模式?\"></a>什么是单例模式?</h3><p>什么是单例模式?顾名思义，就是只有一个实例。即使多次实例化一个类，也只返回第一次的实例。这样说可能比较抽象，看看实际中最简单的单例模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hmacsha256 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'哈希加密'</span>,</span><br><span class=\"line\">  encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hmacsha256.name <span class=\"comment\">// '哈希加密'</span></span><br></pre></td></tr></table></figure>\n<p>上面字面量形式的创建对象，这个对象hmacsha256有两个方法一个变量。可以通过hmacsha256.encrypt()来调用方法。这是我们最常见的单例模式。但是这样写有个特点，就是hmacsha256的所有方法和变量都是公共的，但是如果有一些内部的辅助函数我们不希望暴露出去的话，这样的单例就无法满足我们的需求。</p>\n<h3 id=\"有私有变量的单例模式\"><a href=\"#有私有变量的单例模式\" class=\"headerlink\" title=\"有私有变量的单例模式\"></a>有私有变量的单例模式</h3><p>如果像上面说的那样，不想要把所有的方法和变量都暴露出去，以免有的方法被修改，那我们可以只返回自己想要暴露的方法和变量，就像下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 公有变量和方法（可以访问私有变量和方法） */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            showPrivate();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">      \tdecrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> single = hmacsha256();</span><br><span class=\"line\">single.getValue();  <span class=\"comment\">// '哈希加密'</span></span><br></pre></td></tr></table></figure>\n<p>这样我们对外暴露了3个方法，而name值不在能通过<code>hmacsha256.name</code> 拿到，所以name已经变成了类的私有变量，只有通过<code>single.getValue()</code> 才能拿到，如果，不提供修改这个值的方法，外部就无法修改这个变量。这其实这是一个闭包的典型应用。</p>\n<p>通过这个修改以后发我们发现，这个类在应用这个js的时候初始化一次，但是如果这个js里面的方法一直没有被用到的话，那就等于浪费了一些开销，因为一直没有用到。于是我们希望在引入的时候也不实例化，而是在真正使用的时候在实例化，这就引入了一个<code>懒性单例的概念</code> </p>\n<h3 id=\"懒性单例\"><a href=\"#懒性单例\" class=\"headerlink\" title=\"懒性单例\"></a>懒性单例</h3><p>怎么样能做到引入的时候不实例化呢？我们借助自执行函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 懒性单例写法一 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">   \t<span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*这里定义单例代码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">              showPrivate();</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">          decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">                instance = init(option);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*调用公有的方法来获取实例:*/</span></span><br><span class=\"line\">hmacsha256.getInstance();</span><br></pre></td></tr></table></figure>\n<p>自执行函数，我的理解是一种巧妙的方法，使得我们可以将匿名函数以函数表达式的方式进行创建，并返回匿名函数对象的引用。在结尾加上一对括号，可以调用匿名函数对象的引用，让函数立即被执行。</p>\n<p>这里需要说明一下，<code>()</code> 的作用，<code>()</code> 的作用是迫使js解析器在解析的时候<strong>强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行</strong> 。也就是说<code>(function () {})</code> 这个括号中虽然有function关键字，但是由于有括号，所有解析器并没有把他当做一个function，而是强制把里面的内容转成了一个对象，并返回指向这个对象的指针。</p>\n<p><code>（）</code> 在这里的作用与用<strong>Eval把json格式字符串转换为json对象</strong> 时的作用一样，这就是为啥<code>eval(&quot;(&quot; + testJson + &quot;)&quot;);</code> 一定要多加一个括号的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">\"&#123;&#125;\"</span>);  <span class=\"comment\">// return undefined</span></span><br><span class=\"line\">alert(<span class=\"built_in\">eval</span>(<span class=\"string\">\"(&#123;&#125;)\"</span>);<span class=\"comment\">// return object[Object]</span></span><br></pre></td></tr></table></figure>\n<p>事实上，上面的代码和下面的写法的效果一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 懒性单例写法二 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hmacsha256</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">   \t<span class=\"comment\">/* 私有变量和方法 */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'哈希加密'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*这里定义单例代码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          getValue: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">              showPrivate();</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          encrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">          decrypt: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">                instance = init(option);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*调用公有的方法来获取实例:*/</span></span><br><span class=\"line\">hmacsha256().getInstance();</span><br></pre></td></tr></table></figure>\n<p>但是为什么要使用自执行函数呢？答案就是<strong>隔离作用域</strong> 。第二种写法虽然功能可以实现，但是function hmacsha256这个方法随时候有可能被人改写。第一种写法中，就算你hmacsha256返回上千种方法，里面有再多的私有变量，都不影响其他的作用域。他只管hmacsha256这个变量下的东西，就像有一个命名空间一样。</p>\n<h3 id=\"单例模式解决了什么问题？\"><a href=\"#单例模式解决了什么问题？\" class=\"headerlink\" title=\"单例模式解决了什么问题？\"></a>单例模式解决了什么问题？</h3><p>单例模式只有一个实例，节约了系统的开销。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。比如，工具类，登录框，导航，这些都是系统中单例模式的绝佳使用场景。除了能解决这种业务场景的问题，隔离作用域和模块的分割也是我们使用的最多的姿势。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hmacsha256 = &#123;</span><br><span class=\"line\">  encrypt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  decrypt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getAuthorization = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">token</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> authorization;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  hmacsha256,</span><br><span class=\"line\">  getAuthorization</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式在项目实战应用\"><a href=\"#单例模式在项目实战应用\" class=\"headerlink\" title=\"单例模式在项目实战应用\"></a>单例模式在项目实战应用</h3><p>项目中有个需求是提供一个sdk，初始化以后可以生成一个顶部和右侧的导航栏。这个导航栏真个项目中只有一个，只需要一个实例，这就是典型的单例模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"built_in\">window</span>.mySDK = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initSDK</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">      判断是否登录，获取账号信息</span></span><br><span class=\"line\"><span class=\"comment\">      初始化顶栏和侧边栏</span></span><br><span class=\"line\"><span class=\"comment\">      调用外部传进来的init方法</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showSd</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*控制侧边栏展开还是收起*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetSd</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/*传入新的filter方法并重置左侧导航*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructor</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      initSDK(option);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        head: option.head,<span class=\"comment\">/*初始化顶部的div的id*/</span></span><br><span class=\"line\">        side: option.side,<span class=\"comment\">/*初始左侧导航栏div的id*/</span></span><br><span class=\"line\">        sdHide: option.sdHide,</span><br><span class=\"line\">        showSd: showSd,</span><br><span class=\"line\">        resetSd: resetSd,</span><br><span class=\"line\">        init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">typeof</span>(option.init)===<span class=\"string\">'function'</span> ? option.init() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        signOut: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">typeof</span>(option.signOut)===<span class=\"string\">'function'</span> ? option.signOut() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      getInstance: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">option</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!instance) &#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">constructor</span>(option)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return instance;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">  sdHide: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  resetSd: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mySDK = <span class=\"built_in\">window</span>.mySDK.getInstance(&#123;</span><br><span class=\"line\">  head: <span class=\"string\">'top'</span>,</span><br><span class=\"line\">  side: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">  resetSd: options.filterSd,</span><br><span class=\"line\">  sdHide: options.sdHide,</span><br><span class=\"line\">  init: options.init</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里把实现的具体的内容省去，其实在 initSDK 中做了很多的工作。但这是有关业务的内容，我们需要根据不同的业务员场景自行实现。但运用单例模式，可以保证导航栏只有一个实例。</p>\n<p>其他参考文章：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/34754447\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34754447</a></p>\n"},{"title":"postMesage 理解和应用","date":"2018-02-27T07:07:58.000Z","_content":"\n# postMessage 理解和应用\n\n> 写在前面：学习前端的时候，跨域是一定要学习的。关于跨域的方法有很多种，比如document.domain+iframe，window.name + iframe，jsonp...等等。然鹅在学习的时候苦于没有应用场景，往往当时明白了，没多久又忘了。这次是在项目中真实运用到，所以总结下postMesage 跨域的用法。\n\n\n\n## 业务场景\n\n需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。\n\n场景分析：第三方在页面中初始化SDK,这个SDK生成一个iframe，iframe中有个表单，提交表单，根据同源策略，提交表单发出的请求是向我方服务器发送的，返回的结果也只能在iframe中，如何把iframe中的消息也就是我方服务器返回的结果传给第三方在页面？这就是跨域，于是postMesage 就派上了用场。\n\n## postMessage定义\n\npostMessage是HTML5 中提供的API,功能是可以安全地实现跨源通信。\n\n## 实现\n\n如果想要从a.com域下index.html发送请求给b.com域下index.html，大致如下实现\n\n### a.com/index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>postMessage演示</title>\n</head>\n<body>\n  <iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n  <script>\n  var ifr = document.getElementById('ifr');\n  var targetOrigin = \"http://b.com\";\n  ifr.contentWindow.postMessage(\"hello\",targetOrigin);\n  </script>\n</body>\n</html>\n```\n\n在a.com/index.html中嵌入一个iframe，获取到这个iframe，用iframe.contentWindow.postMessage发送一个信息\n\n### b.com/index.html\n\n```jsx\n<script>\n  window.addEventListener(\"message\",function(event){\n      if(event.origin == 'http://a.com'){\n      alert(event.data);//'hello'\n      alert(event.source);\n  \t}\n  },false)\n </script>\n```\n\n在b.com/index.html中监听window对象，如果有接收到postMessage，就进行处理。\n\n## 应用\n\n看了上面的例子大概就知道怎么动手了。我的需求几乎和例子一样。大致过程如下图：\n\n![postMesage 应用html](postMesage-理解和应用/postMessage.png)\n![postMesage 应用js](postMesage-理解和应用/postMessage1.png)\n## 扩展\n\n1. **window.postMessage() **方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个  [`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent) 消息。 该[`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent)消息有几个属性：**\n\n  + MessageEvent.data(只读)\n\n     是来自发送者的数据\n\n  + MessageEvent.origin\n\n    返回一个表示消息发送者来源的\n\n  + MessageEvent.source\n\n    属性记录调用 **window.postMessage() **方法的窗口信息\n\n  **需要注意： **在使用window.postMessage时，第四步当收到消息之后，一定要验证消息的来源，确保是可信任的的网站发来的消息才可以处理，如果实现拟定一个白名单，这个白名单上的域才能进行处理，否则会出现安全问题。\n\n2. **window.postMessage(message, targetOrigin, [transfer]) **方法有3个参数，第一个参数就是需要发送的数据，第二个参数通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\\*（表示无限制）或者一个URI。由于我们是提供给第三方的SDK，所以不确定信息发送给谁，所以用\\*，**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。**\n\n## 补充\n\n一个SDK如何能再不同的环境使用呢？因为既然要校验白名单才能对消息进行处理，不能每次不同的环境更改白名单。这时候可是使用一个小技巧，就是在js中自定义某个字符串，这个字符串储存白名单，当不同环境获取SDK的时候，我们服务端将这个特定的字符串进行改写。这样就生成了不同环境的SDK了。\n  + 所有环境的SDK代码都是一样的\n  + 在SDK文件中使用$((whiteList))(任意自己定义的格式)这样的自定义语法\n  ```js\n    var whiteDomain = '$((whiteList))';\n  ```\n  + 获取SDK文件时SDK服务端做将$((whiteList))字符串替换\n  + 获取到有不同环境的白名单的SDK\n  + 当SDK收到postMassge发来的请求，获取到postMassge的origin，用origin和whiteDomain进行对比，如果匹配就进行处理，否则不处理\n综上这个方法需要前端和服务端配合完成。\n\n\n\n","source":"_posts/postMesage-理解和应用.md","raw":"---\ntitle: postMesage 理解和应用\ndate: 2018-02-27 15:07:58\ntags:\n- 前端\n- js\n- 跨域\n---\n\n# postMessage 理解和应用\n\n> 写在前面：学习前端的时候，跨域是一定要学习的。关于跨域的方法有很多种，比如document.domain+iframe，window.name + iframe，jsonp...等等。然鹅在学习的时候苦于没有应用场景，往往当时明白了，没多久又忘了。这次是在项目中真实运用到，所以总结下postMesage 跨域的用法。\n\n\n\n## 业务场景\n\n需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。\n\n场景分析：第三方在页面中初始化SDK,这个SDK生成一个iframe，iframe中有个表单，提交表单，根据同源策略，提交表单发出的请求是向我方服务器发送的，返回的结果也只能在iframe中，如何把iframe中的消息也就是我方服务器返回的结果传给第三方在页面？这就是跨域，于是postMesage 就派上了用场。\n\n## postMessage定义\n\npostMessage是HTML5 中提供的API,功能是可以安全地实现跨源通信。\n\n## 实现\n\n如果想要从a.com域下index.html发送请求给b.com域下index.html，大致如下实现\n\n### a.com/index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>postMessage演示</title>\n</head>\n<body>\n  <iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n  <script>\n  var ifr = document.getElementById('ifr');\n  var targetOrigin = \"http://b.com\";\n  ifr.contentWindow.postMessage(\"hello\",targetOrigin);\n  </script>\n</body>\n</html>\n```\n\n在a.com/index.html中嵌入一个iframe，获取到这个iframe，用iframe.contentWindow.postMessage发送一个信息\n\n### b.com/index.html\n\n```jsx\n<script>\n  window.addEventListener(\"message\",function(event){\n      if(event.origin == 'http://a.com'){\n      alert(event.data);//'hello'\n      alert(event.source);\n  \t}\n  },false)\n </script>\n```\n\n在b.com/index.html中监听window对象，如果有接收到postMessage，就进行处理。\n\n## 应用\n\n看了上面的例子大概就知道怎么动手了。我的需求几乎和例子一样。大致过程如下图：\n\n![postMesage 应用html](postMesage-理解和应用/postMessage.png)\n![postMesage 应用js](postMesage-理解和应用/postMessage1.png)\n## 扩展\n\n1. **window.postMessage() **方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个  [`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent) 消息。 该[`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent)消息有几个属性：**\n\n  + MessageEvent.data(只读)\n\n     是来自发送者的数据\n\n  + MessageEvent.origin\n\n    返回一个表示消息发送者来源的\n\n  + MessageEvent.source\n\n    属性记录调用 **window.postMessage() **方法的窗口信息\n\n  **需要注意： **在使用window.postMessage时，第四步当收到消息之后，一定要验证消息的来源，确保是可信任的的网站发来的消息才可以处理，如果实现拟定一个白名单，这个白名单上的域才能进行处理，否则会出现安全问题。\n\n2. **window.postMessage(message, targetOrigin, [transfer]) **方法有3个参数，第一个参数就是需要发送的数据，第二个参数通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\\*（表示无限制）或者一个URI。由于我们是提供给第三方的SDK，所以不确定信息发送给谁，所以用\\*，**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。**\n\n## 补充\n\n一个SDK如何能再不同的环境使用呢？因为既然要校验白名单才能对消息进行处理，不能每次不同的环境更改白名单。这时候可是使用一个小技巧，就是在js中自定义某个字符串，这个字符串储存白名单，当不同环境获取SDK的时候，我们服务端将这个特定的字符串进行改写。这样就生成了不同环境的SDK了。\n  + 所有环境的SDK代码都是一样的\n  + 在SDK文件中使用$((whiteList))(任意自己定义的格式)这样的自定义语法\n  ```js\n    var whiteDomain = '$((whiteList))';\n  ```\n  + 获取SDK文件时SDK服务端做将$((whiteList))字符串替换\n  + 获取到有不同环境的白名单的SDK\n  + 当SDK收到postMassge发来的请求，获取到postMassge的origin，用origin和whiteDomain进行对比，如果匹配就进行处理，否则不处理\n综上这个方法需要前端和服务端配合完成。\n\n\n\n","slug":"postMesage-理解和应用","published":1,"updated":"2018-04-08T12:13:45.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0tzcja000u5ois65vxhq6n","content":"<h1 id=\"postMessage-理解和应用\"><a href=\"#postMessage-理解和应用\" class=\"headerlink\" title=\"postMessage 理解和应用\"></a>postMessage 理解和应用</h1><blockquote>\n<p>写在前面：学习前端的时候，跨域是一定要学习的。关于跨域的方法有很多种，比如document.domain+iframe，window.name + iframe，jsonp…等等。然鹅在学习的时候苦于没有应用场景，往往当时明白了，没多久又忘了。这次是在项目中真实运用到，所以总结下postMesage 跨域的用法。</p>\n</blockquote>\n<h2 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h2><p>需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。</p>\n<p>场景分析：第三方在页面中初始化SDK,这个SDK生成一个iframe，iframe中有个表单，提交表单，根据同源策略，提交表单发出的请求是向我方服务器发送的，返回的结果也只能在iframe中，如何把iframe中的消息也就是我方服务器返回的结果传给第三方在页面？这就是跨域，于是postMesage 就派上了用场。</p>\n<h2 id=\"postMessage定义\"><a href=\"#postMessage定义\" class=\"headerlink\" title=\"postMessage定义\"></a>postMessage定义</h2><p>postMessage是HTML5 中提供的API,功能是可以安全地实现跨源通信。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>如果想要从a.com域下index.html发送请求给b.com域下index.html，大致如下实现</p>\n<h3 id=\"a-com-index-html\"><a href=\"#a-com-index-html\" class=\"headerlink\" title=\"a.com/index.html\"></a>a.com/index.html</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>postMessage演示<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ifr\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.com/index.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> ifr = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ifr'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> targetOrigin = <span class=\"string\">\"http://b.com\"</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  ifr.contentWindow.postMessage(<span class=\"string\">\"hello\"</span>,targetOrigin);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在a.com/index.html中嵌入一个iframe，获取到这个iframe，用iframe.contentWindow.postMessage发送一个信息</p>\n<h3 id=\"b-com-index-html\"><a href=\"#b-com-index-html\" class=\"headerlink\" title=\"b.com/index.html\"></a>b.com/index.html</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(event.origin == <span class=\"string\">'http://a.com'</span>)&#123;</span><br><span class=\"line\">      alert(event.data);<span class=\"comment\">//'hello'</span></span><br><span class=\"line\">      alert(event.source);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  &#125;,<span class=\"literal\">false</span>)</span><br><span class=\"line\"> &lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在b.com/index.html中监听window对象，如果有接收到postMessage，就进行处理。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>看了上面的例子大概就知道怎么动手了。我的需求几乎和例子一样。大致过程如下图：</p>\n<p><img src=\"/2018/02/27/postMesage-理解和应用/postMessage.png\" alt=\"postMesage 应用html\"><br><img src=\"/2018/02/27/postMesage-理解和应用/postMessage1.png\" alt=\"postMesage 应用js\"></p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><ol>\n<li><p><strong>window.postMessage() </strong>方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent\" target=\"_blank\" rel=\"noopener\"><code>MessageEvent</code></a> 消息。 该<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent\" target=\"_blank\" rel=\"noopener\"><code>MessageEvent</code></a>消息有几个属性：**</p>\n<ul>\n<li><p>MessageEvent.data(只读)</p>\n<p>是来自发送者的数据</p>\n</li>\n<li><p>MessageEvent.origin</p>\n<p>返回一个表示消息发送者来源的</p>\n</li>\n<li><p>MessageEvent.source</p>\n<p>属性记录调用 <strong>window.postMessage() </strong>方法的窗口信息</p>\n</li>\n</ul>\n<p><strong>需要注意： </strong>在使用window.postMessage时，第四步当收到消息之后，一定要验证消息的来源，确保是可信任的的网站发来的消息才可以处理，如果实现拟定一个白名单，这个白名单上的域才能进行处理，否则会出现安全问题。</p>\n</li>\n<li><p><strong>window.postMessage(message, targetOrigin, [transfer]) </strong>方法有3个参数，第一个参数就是需要发送的数据，第二个参数通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串*（表示无限制）或者一个URI。由于我们是提供给第三方的SDK，所以不确定信息发送给谁，所以用*，<strong>如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</strong></p>\n</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>一个SDK如何能再不同的环境使用呢？因为既然要校验白名单才能对消息进行处理，不能每次不同的环境更改白名单。这时候可是使用一个小技巧，就是在js中自定义某个字符串，这个字符串储存白名单，当不同环境获取SDK的时候，我们服务端将这个特定的字符串进行改写。这样就生成了不同环境的SDK了。</p>\n<ul>\n<li>所有环境的SDK代码都是一样的</li>\n<li><p>在SDK文件中使用$((whiteList))(任意自己定义的格式)这样的自定义语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> whiteDomain = <span class=\"string\">'$((whiteList))'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取SDK文件时SDK服务端做将$((whiteList))字符串替换</p>\n</li>\n<li>获取到有不同环境的白名单的SDK</li>\n<li>当SDK收到postMassge发来的请求，获取到postMassge的origin，用origin和whiteDomain进行对比，如果匹配就进行处理，否则不处理<br>综上这个方法需要前端和服务端配合完成。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"postMessage-理解和应用\"><a href=\"#postMessage-理解和应用\" class=\"headerlink\" title=\"postMessage 理解和应用\"></a>postMessage 理解和应用</h1><blockquote>\n<p>写在前面：学习前端的时候，跨域是一定要学习的。关于跨域的方法有很多种，比如document.domain+iframe，window.name + iframe，jsonp…等等。然鹅在学习的时候苦于没有应用场景，往往当时明白了，没多久又忘了。这次是在项目中真实运用到，所以总结下postMesage 跨域的用法。</p>\n</blockquote>\n<h2 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h2><p>需要提供给其他业务方一个SDK，这个SDK的功能是：初始化一个登录的表单到指定的位置(div)，然后在这个表单提交后获取到我方服务器返回信息。</p>\n<p>场景分析：第三方在页面中初始化SDK,这个SDK生成一个iframe，iframe中有个表单，提交表单，根据同源策略，提交表单发出的请求是向我方服务器发送的，返回的结果也只能在iframe中，如何把iframe中的消息也就是我方服务器返回的结果传给第三方在页面？这就是跨域，于是postMesage 就派上了用场。</p>\n<h2 id=\"postMessage定义\"><a href=\"#postMessage定义\" class=\"headerlink\" title=\"postMessage定义\"></a>postMessage定义</h2><p>postMessage是HTML5 中提供的API,功能是可以安全地实现跨源通信。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>如果想要从a.com域下index.html发送请求给b.com域下index.html，大致如下实现</p>\n<h3 id=\"a-com-index-html\"><a href=\"#a-com-index-html\" class=\"headerlink\" title=\"a.com/index.html\"></a>a.com/index.html</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>postMessage演示<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ifr\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.com/index.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> ifr = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ifr'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> targetOrigin = <span class=\"string\">\"http://b.com\"</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  ifr.contentWindow.postMessage(<span class=\"string\">\"hello\"</span>,targetOrigin);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在a.com/index.html中嵌入一个iframe，获取到这个iframe，用iframe.contentWindow.postMessage发送一个信息</p>\n<h3 id=\"b-com-index-html\"><a href=\"#b-com-index-html\" class=\"headerlink\" title=\"b.com/index.html\"></a>b.com/index.html</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(event.origin == <span class=\"string\">'http://a.com'</span>)&#123;</span><br><span class=\"line\">      alert(event.data);<span class=\"comment\">//'hello'</span></span><br><span class=\"line\">      alert(event.source);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  &#125;,<span class=\"literal\">false</span>)</span><br><span class=\"line\"> &lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在b.com/index.html中监听window对象，如果有接收到postMessage，就进行处理。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>看了上面的例子大概就知道怎么动手了。我的需求几乎和例子一样。大致过程如下图：</p>\n<p><img src=\"/2018/02/27/postMesage-理解和应用/postMessage.png\" alt=\"postMesage 应用html\"><br><img src=\"/2018/02/27/postMesage-理解和应用/postMessage1.png\" alt=\"postMesage 应用js\"></p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><ol>\n<li><p><strong>window.postMessage() </strong>方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent\" target=\"_blank\" rel=\"noopener\"><code>MessageEvent</code></a> 消息。 该<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent\" target=\"_blank\" rel=\"noopener\"><code>MessageEvent</code></a>消息有几个属性：**</p>\n<ul>\n<li><p>MessageEvent.data(只读)</p>\n<p>是来自发送者的数据</p>\n</li>\n<li><p>MessageEvent.origin</p>\n<p>返回一个表示消息发送者来源的</p>\n</li>\n<li><p>MessageEvent.source</p>\n<p>属性记录调用 <strong>window.postMessage() </strong>方法的窗口信息</p>\n</li>\n</ul>\n<p><strong>需要注意： </strong>在使用window.postMessage时，第四步当收到消息之后，一定要验证消息的来源，确保是可信任的的网站发来的消息才可以处理，如果实现拟定一个白名单，这个白名单上的域才能进行处理，否则会出现安全问题。</p>\n</li>\n<li><p><strong>window.postMessage(message, targetOrigin, [transfer]) </strong>方法有3个参数，第一个参数就是需要发送的数据，第二个参数通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串*（表示无限制）或者一个URI。由于我们是提供给第三方的SDK，所以不确定信息发送给谁，所以用*，<strong>如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</strong></p>\n</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>一个SDK如何能再不同的环境使用呢？因为既然要校验白名单才能对消息进行处理，不能每次不同的环境更改白名单。这时候可是使用一个小技巧，就是在js中自定义某个字符串，这个字符串储存白名单，当不同环境获取SDK的时候，我们服务端将这个特定的字符串进行改写。这样就生成了不同环境的SDK了。</p>\n<ul>\n<li>所有环境的SDK代码都是一样的</li>\n<li><p>在SDK文件中使用$((whiteList))(任意自己定义的格式)这样的自定义语法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> whiteDomain = <span class=\"string\">'$((whiteList))'</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取SDK文件时SDK服务端做将$((whiteList))字符串替换</p>\n</li>\n<li>获取到有不同环境的白名单的SDK</li>\n<li>当SDK收到postMassge发来的请求，获取到postMassge的origin，用origin和whiteDomain进行对比，如果匹配就进行处理，否则不处理<br>综上这个方法需要前端和服务端配合完成。</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Redux理解和应用/redux.png","slug":"redux.png","post":"cjp0tzci800005ois5viwdfcx","modified":0,"renderable":0},{"_id":"source/_posts/function-组件-sdk/component1.png","slug":"component1.png","post":"cjp0tzcij00035oisfg456ov8","modified":0,"renderable":0},{"_id":"source/_posts/function-组件-sdk/component2.png","slug":"component2.png","post":"cjp0tzcij00035oisfg456ov8","modified":0,"renderable":0},{"_id":"source/_posts/function-组件-sdk/postMessage.png","slug":"postMessage.png","post":"cjp0tzcij00035oisfg456ov8","modified":0,"renderable":0},{"_id":"source/_posts/理解正则表达式/reg.png","slug":"reg.png","post":"cjp0tzcj6000r5ois568jcb2f","modified":0,"renderable":0},{"_id":"source/_posts/postMesage-理解和应用/postMessage.png","slug":"postMessage.png","post":"cjp0tzcja000u5ois65vxhq6n","modified":0,"renderable":0},{"_id":"source/_posts/postMesage-理解和应用/postMessage1.png","slug":"postMessage1.png","post":"cjp0tzcja000u5ois65vxhq6n","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjp0tzci800005ois5viwdfcx","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzcio00085oisobuhuzbv"},{"post_id":"cjp0tzci800005ois5viwdfcx","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzcio00095oisr733x3he"},{"post_id":"cjp0tzci800005ois5viwdfcx","tag_id":"cjp0tzcim00055oisomonz9he","_id":"cjp0tzciq000b5oisv3sd3de4"},{"post_id":"cjp0tzci800005ois5viwdfcx","tag_id":"cjp0tzcim00065oiskbrqord9","_id":"cjp0tzciq000c5oisxp7pjhr2"},{"post_id":"cjp0tzcif00015oisi7i2qcyr","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzcis000h5oisliuy8hfq"},{"post_id":"cjp0tzcif00015oisi7i2qcyr","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzcis000i5ois16pvko3x"},{"post_id":"cjp0tzcif00015oisi7i2qcyr","tag_id":"cjp0tzciq000d5oiszcyhzaxe","_id":"cjp0tzcit000k5oisgz4jvc3g"},{"post_id":"cjp0tzcif00015oisi7i2qcyr","tag_id":"cjp0tzcir000e5oistf2vhfdw","_id":"cjp0tzcit000l5oisj8gdihyv"},{"post_id":"cjp0tzcif00015oisi7i2qcyr","tag_id":"cjp0tzcir000f5oisyq89p6vt","_id":"cjp0tzciu000n5oisa9n0kbsw"},{"post_id":"cjp0tzcij00035oisfg456ov8","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzciv000o5oiswdnjejit"},{"post_id":"cjp0tzcij00035oisfg456ov8","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzciv000p5ois77oji69u"},{"post_id":"cjp0tzcij00035oisfg456ov8","tag_id":"cjp0tzcit000m5oisr9wjoz1a","_id":"cjp0tzciv000q5oisdezvlbha"},{"post_id":"cjp0tzcj6000r5ois568jcb2f","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzcjc000w5oisgkk4kr9o"},{"post_id":"cjp0tzcj6000r5ois568jcb2f","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzcjc000x5ois1vs2pwv0"},{"post_id":"cjp0tzcj6000r5ois568jcb2f","tag_id":"cjp0tzcj9000t5oisc95n1k8u","_id":"cjp0tzcjd000z5ois3dzt8xhp"},{"post_id":"cjp0tzcj7000s5oisallxmoo9","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzcjd00105oiszh9e0zrx"},{"post_id":"cjp0tzcj7000s5oisallxmoo9","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzcje00115oisqmblp7uf"},{"post_id":"cjp0tzcj7000s5oisallxmoo9","tag_id":"cjp0tzcjc000v5ois576hpqfl","_id":"cjp0tzcje00125ois18aod7ct"},{"post_id":"cjp0tzcja000u5ois65vxhq6n","tag_id":"cjp0tzcih00025oisr8fakk24","_id":"cjp0tzcje00135oishtl3c49s"},{"post_id":"cjp0tzcja000u5ois65vxhq6n","tag_id":"cjp0tzcil00045oisxphx6miw","_id":"cjp0tzcje00145oismsl9qy6l"},{"post_id":"cjp0tzcja000u5ois65vxhq6n","tag_id":"cjp0tzcjd000y5oisilaxfv3n","_id":"cjp0tzcje00155ois6qhwxphx"}],"Tag":[{"name":"前端","_id":"cjp0tzcih00025oisr8fakk24"},{"name":"js","_id":"cjp0tzcil00045oisxphx6miw"},{"name":"redux","_id":"cjp0tzcim00055oisomonz9he"},{"name":"react","_id":"cjp0tzcim00065oiskbrqord9"},{"name":"单页","_id":"cjp0tzciq000d5oiszcyhzaxe"},{"name":"路由","_id":"cjp0tzcir000e5oistf2vhfdw"},{"name":"权限","_id":"cjp0tzcir000f5oisyq89p6vt"},{"name":"组件","_id":"cjp0tzcit000m5oisr9wjoz1a"},{"name":"正则表达式","_id":"cjp0tzcj9000t5oisc95n1k8u"},{"name":"模式","_id":"cjp0tzcjc000v5ois576hpqfl"},{"name":"跨域","_id":"cjp0tzcjd000y5oisilaxfv3n"}]}}